<!DOCTYPE html><html lang="en" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Bill Hu"><meta name="keywords" content=""><meta name="description" content="CMU 14-513&#x2F;15-213&#x2F;15-513&#x2F;18-513 Intro to Computer Systems, Fall 2024"><meta property="og:type" content="article"><meta property="og:title" content="[Lecture Notes] CMU 15-513 Intro to Computer Systems"><meta property="og:url" content="https://www.billhu.us/2024/051-cmu-15513/index.html"><meta property="og:site_name" content="Bill Hu&#39;s Blog"><meta property="og:description" content="CMU 14-513&#x2F;15-213&#x2F;15-513&#x2F;18-513 Intro to Computer Systems, Fall 2024"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://www.billhu.us/2024/051-cmu-15513/cheatsheet-page1.webp"><meta property="og:image" content="https://www.billhu.us/2024/051-cmu-15513/cheatsheet-page2.webp"><meta property="og:image" content="https://www.billhu.us/2024/051-cmu-15513/elf.webp"><meta property="og:image" content="https://www.billhu.us/2024/051-cmu-15513/linker-puzzle.webp"><meta property="og:image" content="https://www.billhu.us/2024/051-cmu-15513/loading-executable-object-files.webp"><meta property="og:image" content="https://www.billhu.us/2024/051-cmu-15513/file-sharing.webp"><meta property="article:published_time" content="2024-09-03T13:17:06.000Z"><meta property="article:modified_time" content="2025-04-21T18:53:24.559Z"><meta property="article:author" content="Bill Hu"><meta property="article:tag" content="C"><meta property="article:tag" content="Lecture Notes"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://www.billhu.us/2024/051-cmu-15513/cheatsheet-page1.webp"><title>[Lecture Notes] CMU 15-513 Intro to Computer Systems - Bill Hu&#39;s Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.15.6/katex.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/myfont.css"><link rel="stylesheet" href="/css/jetbrains-mono.css"><script id="fluid-configs">var dntVal,Fluid=window.Fluid||{},CONFIG=(Fluid.ctx=Object.assign({},Fluid.ctx),{hostname:"www.billhu.us",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:25,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:3},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},gtag:null},search_path:"/local-search.xml",include_content_in_search:!0});CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script>!function(t,e,n,c,a,r){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(a=e.createElement(c)).async=1,a.src="https://www.clarity.ms/tag/fjnxcr4gva",(r=e.getElementsByTagName(c)[0]).parentNode.insertBefore(a,r)}(window,document,"clarity","script")</script><meta name="google-site-verification" content="IqNfw3GiMxuhw7kYoEdhMJoh3j99KHuGI9bw00hPn2c"><link href="https://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Kaushan+Script" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic,700italic" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto+Slab:400,100,300,700" rel="stylesheet"><meta name="generator" content="Hexo 7.1.1"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Bill Hu&#39;s Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>Home</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>Archives</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>Categories</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>Tags</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>About</span></a></li><li class="nav-item"><a class="nav-link" href="https://www.billhu.xyz" target="_self"><i class="iconfont icon-code"></i> <span>Portfolio</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="[Lecture Notes] CMU 15-513 Intro to Computer Systems"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-09-03 13:17" pubdate>September 3, 2024 pm</time></span></div><div class="mt-1"></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">[Lecture Notes] CMU 15-513 Intro to Computer Systems</h1><div class="markdown-body"><div class="note note-info"><p>Disclaimer: 记得不全，已经会的都没记，不建议用作参考。</p></div><h1 id="my-cheatsheet"><a class="markdownIt-Anchor" href="#my-cheatsheet"></a> My Cheatsheet</h1><img src="/2024/051-cmu-15513/cheatsheet-page1.webp" srcset="/img/loading.gif" lazyload> <img src="/2024/051-cmu-15513/cheatsheet-page2.webp" srcset="/img/loading.gif" lazyload><h1 id="lec-3-machine-level-programming-i"><a class="markdownIt-Anchor" href="#lec-3-machine-level-programming-i"></a> Lec 3. Machine-Level Programming I</h1><ul><li>x86-64 integer registers<ul><li><code>%rax</code> 64-bit</li><li><code>%eax</code> 32-bit, <code>%ax</code> 16-bit, <code>%ah</code> <code>%al</code> high 8-bit and low 8-bit respectively</li><li>backwards compatibility 向下兼容❎ 历史包袱✅</li></ul></li></ul><table><thead><tr><th>Register</th><th></th><th></th><th>Origin (许多已废弃)</th></tr></thead><tbody><tr><td><code>rax</code> (eax, ax, ah, al)</td><td></td><td></td><td>Accumulate 累加器</td></tr><tr><td><code>rbx</code> <code>ebx</code></td><td></td><td></td><td>Base 基地址(例如数组首地址 和si di差不多)</td></tr><tr><td><code>rcx</code> <code>ecx</code></td><td></td><td></td><td>Counter</td></tr><tr><td><code>rdx</code> <code>edx</code></td><td></td><td></td><td>Data</td></tr><tr><td><code>rsi</code> <code>esi</code></td><td></td><td></td><td>Source Index (源变址)</td></tr><tr><td><code>rdi</code> <code>edi</code></td><td></td><td></td><td>Destination Index (目的变址)</td></tr><tr><td><code>rsp</code> <code>esp</code></td><td></td><td></td><td>Stack Pointer</td></tr><tr><td><code>rbp</code> <code>ebp</code></td><td></td><td></td><td>Base Pointer</td></tr><tr><td><code>r8</code> <code>r8d</code></td><td></td><td></td><td></td></tr><tr><td><code>r9</code>, <code>r10</code>, <code>r11</code>, …, <code>r15</code></td><td></td><td></td><td></td></tr></tbody></table><p>关于 bx/bp/si/di 寄存器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">a[<span class="hljs-number">10</span>] --&gt; b[<span class="hljs-number">10</span>]<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>	b[i] = a[i];<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">	a -- source index      -- si register</span><br><span class="hljs-comment">	b -- destination index -- di register</span><br><span class="hljs-comment">	现在 bx bp si di差不多</span><br><span class="hljs-comment">	以前 si di用于数组中(用户), bx操作系统解决程序重定向问题使用 (程序每次加载到内存中都是不同地址 relative addressing)</span><br><span class="hljs-comment">	bx和bp段不一样, bx si di数据段, bp 堆栈段(ss, stack segment)</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><ul><li><p>Operands 操作数</p><ul><li><strong>Immediate</strong>: e.g. <code>$0x400</code>, <code>$-533</code> (1, 2 or 4 bytes)</li><li><strong>Register</strong>: e.g. <code>%rax</code>, <code>%r13</code>.<ul><li>But <code>%rsp</code> reserved for special use.</li></ul></li><li><strong>Memory</strong>: 8-byte mem at addr given by reg: e.g. <code>(%rax)</code>.</li></ul></li><li><p><code>movq</code> operand combinations</p><ul><li>✅ imm to reg: <code>movq $0x4, %rax</code></li><li>✅ imm to mem: <code>movq $-147, (%rax)</code></li><li>✅ reg to reg: <code>movq %rax, %rdx</code></li><li>✅ reg to mem: <code>movq %rax, (%rdx)</code></li><li>✅ mem to reg: <code>movq (%rax), %rdx</code></li><li>❌ <strong>Cannot do mem-mem transfer</strong>!</li></ul></li><li><p>Complete mem addressing modes</p><ul><li><p><strong>D(Rb, Ri, S) = MEM[Reg[Rb] + S*Reg[Ri] + D]</strong> (类似二维数组)</p><ul><li><p>D: constant 1, 2, or 4 bytes</p></li><li><p>Rb: base register</p></li><li><p>Ri: index register (except <code>%rsp</code>)</p></li><li><p>S: scale 1, 2, 4, or 8</p></li><li><p>关于数组寻址</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">二维数组array<span class="hljs-selector-attr">[10]</span><span class="hljs-selector-attr">[20]</span><br>访问 <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[2]</span><span class="hljs-selector-attr">[3]</span> = <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[2*20+3]</span><br>a=Reg<span class="hljs-selector-attr">[Rb]</span>基地址, <span class="hljs-number">2</span>=Reg<span class="hljs-selector-attr">[Ri]</span>(下标i), <span class="hljs-number">20</span>=S (数组是int还是short等)<br><br>二维数组  基址变址寻址 (基址rb bx bp, 变址si di)<br>一维数组  <br></code></pre></td></tr></table></figure></li></ul></li><li><p>Special case:</p><ul><li><strong>(Rb, Ri) = MEM[Reg[Rb] + Reg[Ri]]</strong></li><li><strong>D(Rb, Ri) = MEM[Reg[Rb] + Reg[Ri] + D]</strong></li><li><strong>(Rb, Ri, S) = MEM[Reg[Rb] + S*Reg[Ri]]</strong></li></ul></li></ul></li><li><p>Some arithmetic operations</p><ul><li><code>add</code>, <code>sub</code>, <code>imul</code> (<code>imul</code> 带符号乘法; <code>mul</code> 无符号乘法)</li><li><code>sal</code> <code>shl</code> (left shift), <code>sar</code> (arithmetic right shift), <code>shr</code> (logical)</li><li><code>xor</code>, <code>and</code>, <code>or</code></li><li><code>inc</code> (++dest), <code>dec</code> (–dest), <code>neg</code> (-dest), <code>not</code> (~dest)</li><li><code>lea</code> (load effective address 把存储单元的地址给dst)<ul><li>CPU designers’ inteneded use: calculate pointer</li><li>Compiler often do: ordinary arithmetic<ul><li>e.g. <code>lea (%rbx, %rbx, 2), %rax</code> means <code>rax = rbx * 3</code>.</li></ul></li></ul></li></ul></li><li><p>In most instructions, a memory operand access memory. <strong>LEA is exception!</strong></p></li></ul><h1 id="lec-4-machine-control"><a class="markdownIt-Anchor" href="#lec-4-machine-control"></a> Lec 4. Machine Control</h1><ul><li><p><strong>EFLAGS</strong> (RFLAGS in 64-bit) register</p><ul><li><strong>CF (Carry Flag)</strong>: unsigned overflow 进位(+)或借位(-)<ul><li>e.g. uint8_t 255+1=0</li></ul></li><li><strong>ZF (Zero Flag)</strong>: zero</li><li><strong>SF (Sign Flag)</strong>: negative 最高位为1 / 判断负数</li><li><strong>OF (Overflow Flag)</strong>: signed overflow<ul><li>两个正数相加得到负数，或两个负数相加得到正数</li><li>最高位w,y, <code>w == y &amp;&amp; w != z</code></li><li>e.g. int8_t 127+1=-128</li></ul></li><li><strong>PF (Parity Flag)</strong></li><li>一般算术运算会影响所有标志位</li><li>一般逻辑运算会更改eflags然后把CF和OF置零（因为：逻辑运算只和本位有关）</li><li>传送类指令<code>mov</code>, <code>lea</code> 等不影响标志位</li></ul></li><li><p>Compare</p><ul><li><code>cmp a, b</code>: compute b-a, update condition codes<ul><li><code>sub</code>和<code>cmp</code>唯一的区别在于减出来的差值是否保留</li></ul></li><li><code>test a, b</code>: compute b&amp;a, update SF and ZF<ul><li><code>test</code>和<code>and</code>唯一的区别在于结果是否保留</li><li>e.g. 测试某一个bit是否为1，可使用 test reg, 0b000100 指令，接下来使用 jz 判断是否全零</li><li>e.g. test reg, reg 将自己和自己相与，可判断是否自己是零（和 cmp reg 0一致，但硬件层面逻辑运算速度很快，逻辑运算(与门)比算术运算(sub)运算快，因此选择test指令）</li></ul></li></ul></li><li><p>Jump</p><table><thead><tr><th>指令 和等效标记</th><th>判断条件 (不用记)</th><th></th><th></th></tr></thead><tbody><tr><td><code>jmp</code></td><td>true</td><td>jump 无条件跳转</td><td></td></tr><tr><td><code>je</code> <code>jz</code></td><td>ZF</td><td>Equal / Zero</td><td></td></tr><tr><td><code>jne</code> <code>jnz</code></td><td>~ZF</td><td>Not Equal / Not Zero</td><td></td></tr><tr><td><code>js</code></td><td>SF</td><td>负数</td><td></td></tr><tr><td><code>jns</code></td><td>~SF</td><td>非负数</td><td></td></tr><tr><td><code>jg</code> <code>jnle</code></td><td>ZF=0 and SF=OF</td><td>&gt; (signed)</td><td></td></tr><tr><td><code>jge</code> <code>jnl</code></td><td>SF=OF</td><td>&gt;= (signed)</td><td></td></tr><tr><td><code>jl</code> <code>jnge</code></td><td>SF != OF</td><td>&lt; (signed)</td><td></td></tr><tr><td><code>jle</code> <code>jng</code></td><td>ZF=1 or SF != OF</td><td>&lt;= (signed)</td><td></td></tr><tr><td><code>ja</code> <code>jnbe</code></td><td>CF=0 and ZF=0</td><td>&gt; (unsigned)</td><td></td></tr><tr><td><code>jb</code> <code>jnae</code> <code>jc</code></td><td>CF</td><td>&lt; (unsigned)</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><code>jae</code> <code>jnb</code> <code>jnc</code></td><td>CF=0</td><td>&gt;= (unsigned)</td><td></td></tr><tr><td><code>jbe</code> <code>jna</code></td><td>CF=1 or BF=1</td><td>&lt;= (unsigned)</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table></li><li><p>Set</p><ul><li>将condition codes赋值给寄存器低1字节? 高7字节不会修改</li></ul></li></ul><h1 id="lec-5-machine-level-programming-procedures"><a class="markdownIt-Anchor" href="#lec-5-machine-level-programming-procedures"></a> Lec 5. Machine-Level Programming - Procedures</h1><p>x86-64 stack</p><ul><li><p><code>pushq</code> src: decrement <strong>rsp</strong> by 8</p></li><li><p><code>popq</code> dest: increment <strong>rsp</strong> by 8, copy value</p></li><li><p><code>call label</code>: push <strong>return address</strong> on stack (address of the next instruction after call), jump to label</p></li><li><p><code>ret</code>: pop address from stack, jump to that address</p></li></ul><p>传参</p><ul><li>前六个参数: <code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>rcx</code>, <code>r8</code>, <code>r9</code></li><li>更多的参数放在stack中</li><li>返回值: <code>rax</code></li></ul><p>Managing local data / 递归函数 Frame</p><ul><li>Stack allocated in <strong>Frames</strong></li></ul><p>Register Saving Conventions</p><ul><li><strong>Caller</strong> Saved (Call-<strong>Clobbered</strong>)<ul><li>rax (return value)</li><li>rdi, rsi, rdx, rcx, r8, r9 (arguments)</li></ul></li><li><strong>Callee</strong> Saved (Call-<strong>Preserved</strong>)<ul><li>rbx, r10, r11, r12, r13, r14, r15 (temporaries)</li><li>rbp (maybe used as frame pointer, can mix &amp; match)</li><li>rsp (special: restored to original value upon exit)</li></ul></li></ul><h1 id="lec-6-machine-level-programming-data"><a class="markdownIt-Anchor" href="#lec-6-machine-level-programming-data"></a> Lec 6. Machine-Level Programming - Data</h1><p>Arrays 略</p><p>Structures 略</p><p>Floating Point</p><ul><li>Arguments passed in <code>%xmm0</code>, <code>%xmm1</code>, …</li><li>All XMM reg are <strong>call-clobbered (caller saved)</strong></li></ul><h1 id="lec-7-machine-advanced"><a class="markdownIt-Anchor" href="#lec-7-machine-advanced"></a> Lec 7. Machine Advanced</h1><h3 id="buffer-overflow"><a class="markdownIt-Anchor" href="#buffer-overflow"></a> Buffer overflow</h3><ul><li>#1 technical cause of security vulnerabilities<ul><li>#1 overall cause is social engineering / user ignorance</li></ul></li><li><strong>Stack smashing</strong> attacks: overwrite return address, to jump to other code<ul><li>code injection attacks: input string contains byte representation of executable code</li><li>How to avoid?<ul><li><strong>Avoid overflow vulnerabilities</strong>: e.g. <code>fgets(buf, 4, stdin)</code> instead of <code>gets</code></li><li><strong>Randomized stack offsets</strong>: at the start of program, reposition stack. Makes it difficult for hacker to predict beginning of inserted code.</li><li><strong>Non-executable memory</strong>: mark regions of mem as not executable. If jump into such region, immediate crash.</li><li><strong>Stack canaries</strong>: 在stack的局部变量和返回地址之间插入一个特殊的标记值canary, 函数返回前检查该值是否被修改.</li></ul></li></ul></li><li><strong>Return-oriented Programming</strong> attacks (ROP)<ul><li>不插入恶意代码，而是利用现有程序中的代码片段 (gadgets) 通常以<code>ret</code>结尾</li></ul></li></ul><h3 id="union"><a class="markdownIt-Anchor" href="#union"></a> Union</h3><h1 id="lec-8-design-and-debugging"><a class="markdownIt-Anchor" href="#lec-8-design-and-debugging"></a> Lec 8. Design and Debugging</h1><ul><li>defect, error, failure (defeat, error not necessarily a failure)</li><li>scientific debugging<ul><li>hypothesis, prediction, experiment, observation &amp; conclusion, hypothesis, …</li></ul></li></ul><p>Design</p><p>…</p><p>TODO</p><h1 id="lec-9-memory-hierarchy"><a class="markdownIt-Anchor" href="#lec-9-memory-hierarchy"></a> Lec 9. Memory Hierarchy</h1><ul><li>The memory abstraction<ul><li><strong>bus</strong> 总线</li></ul></li><li>RAM (<strong>SRAM</strong> / static RAM, <strong>DRAM</strong> / dynamic RAM)<ul><li>DRAM: 1 transistor, 1 capacitor per bit; must refresh state periodically</li><li>SRAM: 6 transistors per bit; holds state indefinitely (but will still lose data on power loss)</li><li>SRAM is more expensive</li></ul></li><li>Memory hierarchy<ul><li>Big idea (ideal): creates a large pool of storage that costs as much as the cheap storage near the bottom, but that serves data to programs at the rate of the fast storage near the top.</li></ul></li><li>Cache<ul><li><p>locality</p></li><li><p>3 type of cache misses: <strong>cold (compulsory)</strong> miss, <strong>capacity</strong> miss, <strong>conflict</strong> miss</p><ul><li>cold misses: first reference to the block; misses with infinitely large cache</li><li>capacity miss: occurs when the set of active cache blocks is larger than the cache; additional misses from finite-sized cache with no placement restrictions</li><li>conflict miss: occurs when the cache is large enough but too many data all map (by the placement policy) to the same limited set of blocks</li></ul></li></ul></li></ul><h1 id="lec-10-cache-memories"><a class="markdownIt-Anchor" href="#lec-10-cache-memories"></a> Lec 10. Cache Memories</h1><p>CPU cache memory</p><ul><li>small, fast SRAM-based memories.</li></ul><p>General cache organization (<strong>S, E, B</strong>)</p><ul><li>Cache size = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>×</mo><mi>E</mi><mo>×</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">S \times E \times B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.76666em;vertical-align:-.08333em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.76666em;vertical-align:-.08333em"></span><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05017em">B</span></span></span></span> data bytes<ul><li>一条cache line: valid bit + tag + B=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">2^b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.849108em;vertical-align:0"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.849108em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span></span></span></span> bytes per cache block</li></ul></li><li>一条地址: t bits - tag, s bits - set index, b bits - block offset</li><li>Direct Mapped cache: E = 1, one line per set</li><li></li></ul><p>About Writes</p><ul><li><p>What to do on a write-hit?</p><ul><li><p><strong>write-through</strong>: write immediately to memory</p></li><li><p><strong>write-back</strong>: defer write to memory until replacement of line (needs <strong>dirty bit</strong> for each cache line)</p></li></ul></li><li><p>What to do on a write-miss?</p><ul><li><strong>write-allocate</strong>: load into cache, update line in cache (good if more writes to the location will follow)</li><li><strong>no-write-allocate</strong>: write straight to memory</li></ul></li><li><p>Typical:</p><ul><li>write through + no write allocate</li><li><strong>write-back</strong> + <strong>write-allocate</strong></li></ul></li><li><p>When write, the entire block of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">2^b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.849108em;vertical-align:0"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.849108em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span></span></span></span> bytes are written back to memory.</p></li></ul><p>Rearranging loops to improve <strong>spatial locality</strong> 矩阵乘法为例</p><ul><li><p>description:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ijk</span><br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;n; i++) &#123;<br>	<span class="hljs-keyword">for</span> (j=<span class="hljs-number">0</span>; j&lt;n; j++) &#123;<br>		sum = <span class="hljs-number">0.0</span>;  <span class="hljs-comment">// variable sum in register.</span><br>		<span class="hljs-keyword">for</span> (k=<span class="hljs-number">0</span>; k&lt;n; k++) &#123;<br>			sum += a[i][k] * b[k][j];<br>		&#125;<br>		c[i][j] = sum;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>O(N^3)</p><p>假设block size为32bytes (能够存下4个double)</p></li><li><p>look at the access pattern:</p><ul><li>Stepping through <strong>columns</strong> in one row: <code>for (i=0; i&lt;N; i++) sum += a[0][i]</code><ul><li>exploit spatial locality, miss rate = sizeof(aij)/B</li></ul></li><li>Stepping through <strong>rows</strong> in one column: <code>for (i=0; i&lt;N; i++) sum += a[i][0]</code><ul><li>no spatial locality, miss rate = 100%</li></ul></li><li>接下来看内层循环: <code>sum += a[i][k] * b[k][j];</code><ul><li>这里对于A的访问是stepping through columns, 对于B的访问是stepping through rows</li><li>Miss rate: A 25%, B 100%, C 0%</li><li>那么总miss per iteration是0.5</li><li>上面是ijk的情况，同理可得kij也是0.5，而其它 ijk, jik 为1.25, jki, kji 为2.0</li></ul></li></ul></li></ul><p>Use blocking to improve <strong>temporal locality</strong></p><ul><li><p>code</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">c = (<span class="hljs-type">double</span>*) <span class="hljs-built_in">calloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">double</span>), n*n);<br><br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;n; i+=B) &#123;<br>    <span class="hljs-keyword">for</span> (j=<span class="hljs-number">0</span>; i&lt;n; j+=B) &#123;<br>        <span class="hljs-keyword">for</span> (k=<span class="hljs-number">0</span>; k&lt;n; k+=B) &#123;<br>            <span class="hljs-comment">// B x B mini matrix multiplication</span><br>            <br>            <span class="hljs-keyword">for</span> (i1=i; i1&lt;i+B; i1++) &#123;<br>                <span class="hljs-keyword">for</span> (j1=j; j1&lt;j+B; j1++) &#123;<br>                    <span class="hljs-keyword">for</span> (k1=k; k1&lt;k+B; k1++) &#123;<br>                        c[i1 * n + j1] += a[i1 * n + k1] * b[k1 * n + j1]<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="lec-11-virtual-memory"><a class="markdownIt-Anchor" href="#lec-11-virtual-memory"></a> Lec 11. Virtual Memory</h1><p>VM is a tool for memory management.</p><p><strong>Loading</strong>:</p><ul><li><code>execve</code> allocates virtual pages for .text and .data sections, and creates PTEs marked as invalid</li></ul><p>page hit: reference to VM word that is in physical memory (DRAM cache hit)</p><p><strong>page fault</strong>: not in physical memory (DRAM cache miss)</p><p>valid bit = 0: page not in memory (<strong>page fault</strong>)</p><p>On page fault:</p><ul><li>valid bit = 0, MMU triggers page fault exception</li><li>handler identifies <strong>victim</strong> (and, if dirty, pages it out to disk)</li><li>handler pages in new page and updates PTE in memory</li><li>handler returns to original process, <strong>restarting</strong> faulting instruction</li></ul><h1 id="lec-12-virtual-memory-details"><a class="markdownIt-Anchor" href="#lec-12-virtual-memory-details"></a> Lec 12. Virtual Memory: Details</h1><h1 id="lec-13-malloc"><a class="markdownIt-Anchor" href="#lec-13-malloc"></a> Lec 13. Malloc</h1><p>dynamic memory allocators (such as <code>malloc</code>).</p><p>Explicit allocator: application allocates and frees space. E.g. C,C++ malloc, free</p><p>Implicit allocator: application allocates, but does not free space. E.g. Java new</p><h2 id="the-malloc-package"><a class="markdownIt-Anchor" href="#the-malloc-package"></a> The <strong>malloc</strong> package</h2><ul><li>On successful: returns a ptr to mem of at least <code>size</code> bytes, <strong>aligned to 16-byte boundary</strong> (on x64)</li><li>Unsuccessful: returns NULL and sets <code>errno</code></li><li>Other functions: <code>free</code>, <code>calloc</code>, <code>realloc</code></li><li><code>sbrk</code>: used internally by allocators to grow or shrink the heap</li></ul><p>Performance goal: <strong>Throughput</strong></p><ul><li>Given some sequence of <code>malloc</code> and <code>free</code> requests, Goal: maximize throughput and peak memory utilization.</li><li>Throughput: number of completed requests per unit time.</li><li>Def: <strong>Aggregate payload</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">P_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.33610799999999996em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03148em">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span><ul><li><code>malloc(p)</code> results in a block with a <strong>payload</strong> of <code>p</code> bytes</li><li>The <strong>aggregate payload</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">P_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.33610799999999996em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03148em">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> is the sum of currently allocated payloads</li><li>The <strong>peak aggregate payload</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>max</mi><mo>⁡</mo></mo><mrow><mi>i</mi><mo>≤</mo><mi>k</mi></mrow></msub><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\max_{i\leq k}P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.928509em;vertical-align:-.24517899999999998em"></span><span class="mop"><span class="mop">max</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3361079999999999em"><span style="top:-2.5500000000000003em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight" style="margin-right:.03148em">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.24517899999999998em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> is the max aggregate payload at any point in the sequence up to request</li></ul></li><li>Def: <strong>Current heap size</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">H_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.08125em">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.33610799999999996em"><span style="top:-2.5500000000000003em;margin-left:-.08125em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03148em">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span><ul><li>Assume heap only grows when <code>sbrk</code>, never shrinks</li></ul></li><li>Def: <strong>Overhead</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>O</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">O_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.33610799999999996em"><span style="top:-2.5500000000000003em;margin-left:-.02778em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03148em">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span><ul><li>Fraction of heap space NOT used for program data</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>O</mi><mi>k</mi></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi>H</mi><mi>k</mi></msub><mi mathvariant="normal">/</mi><msub><mo><mi>max</mi><mo>⁡</mo></mo><mrow><mi>i</mi><mo>≤</mo><mi>k</mi></mrow></msub><msub><mi>P</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>−</mo><mn>1.0</mn></mrow><annotation encoding="application/x-tex">O_k = (H_k / \max_{i\leq k}P_i) - 1.0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.33610799999999996em"><span style="top:-2.5500000000000003em;margin-left:-.02778em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03148em">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:.08125em">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.33610799999999996em"><span style="top:-2.5500000000000003em;margin-left:-.08125em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03148em">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mop"><span class="mop">max</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3361079999999999em"><span style="top:-2.5500000000000003em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">≤</span><span class="mord mathnormal mtight" style="margin-right:.03148em">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.24517899999999998em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">0</span></span></span></span></li></ul></li></ul><h2 id="fragmentation"><a class="markdownIt-Anchor" href="#fragmentation"></a> <strong>Fragmentation</strong></h2><ul><li><strong>Internal fragmentation</strong>: occurs if payload &lt; block size<ul><li>caused by:<ul><li>overhead for maintaining heap data structures</li><li>padding for alignment</li><li>explicit policy decisions</li></ul></li><li>depends only on the pattern of <strong>previous</strong> requests. Thus easy to measure.</li></ul></li><li><strong>External fragmentation</strong>: enough aggregate heap mem, but no single free block is big enough<ul><li>depends on future. Thus difficult to measure.</li></ul></li></ul><h2 id="implementation"><a class="markdownIt-Anchor" href="#implementation"></a> Implementation</h2><p><strong>Standard method</strong></p><ul><li>keep the length (in bytes) of a block in the word <strong>preceding</strong> the block 在分配的block之前存放信息</li><li>word is often called <strong>header field</strong> or <strong>header</strong></li><li>To keep track of free blocks<ul><li>method 1: <strong>implicit list</strong> using length - links all blocks 每个header的位置记录下一个的指针<ul><li>need to tag each block as allocated/free</li></ul></li><li>method 2: <strong>explicit list</strong> among the free blocks using pointers 存一堆指针<ul><li>need space for pointers</li></ul></li><li>method 3: <strong>segregated free list</strong><ul><li>different free lists for different size classes</li></ul></li><li>method 4: <strong>blocks sorted by size</strong><ul><li>can use a balanced tree (e.g. 红黑树) with pointers within each free block, and the length used as a key</li></ul></li></ul></li></ul><h2 id="method1-implicit-free-list"><a class="markdownIt-Anchor" href="#method1-implicit-free-list"></a> <strong>Method1: Implicit free list</strong></h2><p>每个block的header需要存放size和allocated/free状态，需要两个word，比较浪费</p><p>由于分配内存的地址的低几位肯定是0 (因为要16-byte对齐), 所以省略这个低几位，用这几位的空间存放allocated/free 状态。读出size的时候mask out这低几位。</p><ul><li>Finding a free block<ul><li><strong>first fit</strong>: search list from beginning, choose the first free block that fits<ul><li>finding space for <code>asize</code> bytes (including header)</li><li>can cause “splinters” at the beginning of list</li></ul></li><li><strong>next fit</strong>: search starts where previous search finished<ul><li>faster than first fit. but fragmentation might be worse.</li></ul></li><li><strong>best fit</strong>: search the list and choose the best free block (with fewest bytes left over)<ul><li>keep fragments small - usually improves memory utilization</li><li>typically slower.</li><li>still a greedy algorithm, not optimal.</li></ul></li></ul></li><li>Allocating in a free block: <strong>splitting</strong><ul><li>因为需要分配的空间可能小于这一段空余空间，所以可以对block进行split</li><li>在free的时候，可以只清空allocated block。会导致 <strong>false fragmentation</strong> (有足够大的连续可用空间，但allocator无法找到)</li></ul></li><li><strong>Coalescing</strong>: join (coalesce) with next/prev blocks, if they are free<ul><li>将free block与紧邻的free block合并</li><li>如何找到之前的block?</li><li><strong>Boundary tags</strong>: 在free block的末尾重复一遍size/allocated信息。</li></ul></li></ul><p>Summary:</p><ul><li>Implementation: very simple</li><li>Allocate: worst case linear time. 所以不在malloc/free中使用。</li><li>Free: constant time (even with coalescing)</li></ul><h1 id="lec-14-malloc-advanced"><a class="markdownIt-Anchor" href="#lec-14-malloc-advanced"></a> Lec 14. Malloc: Advanced</h1><h2 id="method2-explicit-free-lists"><a class="markdownIt-Anchor" href="#method2-explicit-free-lists"></a> Method2: Explicit free lists</h2><p>Explicit list among the free blocks using pointers</p><p>Maintain list of <strong>free</strong> blocks, not all blocks.</p><h1 id="lec-15-code-optimization"><a class="markdownIt-Anchor" href="#lec-15-code-optimization"></a> Lec 15. Code Optimization</h1><h2 id="goals-of-compiler-optimization"><a class="markdownIt-Anchor" href="#goals-of-compiler-optimization"></a> Goals of compiler optimization</h2><ul><li>minimize num of instructions (remove unnecessary calc, avoid slow instructions)</li><li>avoid waiting for memory (keep in registers, cache-friendly, load data from mem early &amp; only once)</li><li>avoid branching (make prediction easier, unroll loops)</li></ul><h2 id="limits"><a class="markdownIt-Anchor" href="#limits"></a> Limits</h2><ul><li>generally cannot improve algorithmic complexity</li><li>cannot cause any change in behavior (including edge cases)</li><li>often only analyze one func at a time (exception: inline func)</li><li>tricky to anticipate run-time inputs</li></ul><h2 id="two-kinds-of-optimizations"><a class="markdownIt-Anchor" href="#two-kinds-of-optimizations"></a> Two kinds of optimizations</h2><ul><li><strong>Local optimizations</strong>: work inside a single basic block (const folding, strength reduction, dead code elimination, local CSE (Common Subexpression Elimination))</li><li><strong>Global optimizations</strong>: process the entire control flow graph fo a func (loop transformations, code motion, global CSE)</li></ul><h2 id="examples-of-optimization"><a class="markdownIt-Anchor" href="#examples-of-optimization"></a> Examples of optimization</h2><ul><li><p>Constant following</p></li><li><p>Dead code elimination</p><ul><li><code>if (0)</code> remove</li><li>overwritten result. e.g.<code>x = 23; x = 42;</code></li></ul></li><li><p>Common subexpression elimination</p><ul><li><pre class="highlight"><code class="c">norm[i] = v[i].x*v[i].x + v[i].y*v[i].y;
&lt;!--code￼<span class="hljs-number">4</span>--&gt;

</code></pre></li></ul></li><li><p><strong>Code motion</strong>: move calculations out of a loop (only valid if every iteration produces same result)</p><ul><li><p>e.g.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> j;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>		a[n*i+j] = b[j];<br></code></pre></td></tr></table></figure></li><li><p>optimized:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> j;<br><span class="hljs-type">int</span> ni = n*i;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>		a[ni+j] = b[j];<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>Inlining</strong>: copy body of a func into its caller (but can make code bigger and slower)</p></li></ul><h2 id="obstacles-to-optimization"><a class="markdownIt-Anchor" href="#obstacles-to-optimization"></a> Obstacles to optimization</h2><ul><li><strong>Memory aliasing</strong>: 两个指针或引用引用的是同一块内存，编译器不知道改变一个会不会影响其它<ul><li>solution: use intermediate result; or use <code>restrict</code> keyword</li></ul></li><li>Can’t move function calls out of loops</li></ul><h2 id="machine-dependent-optimization"><a class="markdownIt-Anchor" href="#machine-dependent-optimization"></a> Machine-dependent optimization</h2><ul><li>Branches are a challenge<ul><li>a simple heuristic:<ul><li>Backwards branches are often loops, so predict taken</li><li>Forward branches are often ifs, so predict not taken</li></ul></li><li>fancier algorithms track behavior of each branch</li><li>optimizing for branch prediction<ul><li>reduce number of branches (transform loops, unroll loops)</li><li>make branches predictable (sort data, avoid indirect branches e.g. func ptr, virtual methods)</li></ul></li></ul></li><li>Loop unrolling</li><li>Scheduling<ul><li>rearrange instructions to make it easier for CPU to keep all functional units busy</li><li>e.g. move all loades (memory) to top of an unrolled loop</li></ul></li></ul><h1 id="lec-16-linking"><a class="markdownIt-Anchor" href="#lec-16-linking"></a> Lec 16. Linking</h1><ul><li>Why linkers?<ul><li>Modularity; Efficiency</li></ul></li></ul><h2 id="what-do-linkers-do"><a class="markdownIt-Anchor" href="#what-do-linkers-do"></a> What do linkers do?</h2><p>Step 1: <strong>Symbol resolution</strong></p><ul><li>Symbol definitions stored in object files in <strong>symbol table</strong></li><li>Linker associates each symbol reference with exactly 1 symbol definition</li></ul><p>Step 2: <strong>Relocation</strong></p><ul><li></li></ul><p><strong>3 kinds of object files</strong> (modules)</p><ul><li><code>.o</code> relocatable object file</li><li><code>a.out</code> executable object file</li><li><code>.so</code> shared object file</li></ul><p><strong>ELF</strong></p><ul><li>standard binary format for object files.</li><li><img src="/2024/051-cmu-15513/elf.webp" srcset="/img/loading.gif" lazyload></li></ul><p><strong>Linker symbols:</strong></p><ul><li><strong>global symbols</strong>: can be referenced by other modules</li><li><strong>external symbols</strong>: references other modules</li><li><strong>local symbols</strong>: within module. Local linker symbols IS NOT local program variables.</li></ul><p><strong>Linker’s symbol rules</strong></p><ul><li><p><strong>strong symbol</strong>: 函数、有初始化的全局变量</p></li><li><p><strong>weak symbol</strong>: extern变量、未初始化的全局变量</p></li><li><p>Rule 1: Multiple strong symbols not allowed</p></li><li><p>Rule 2: Given a strong symbol and multiple weak symbols, choose the strong symbol</p></li><li><p>Rule 3: If multiple weak symbols, pick an arbitrary one.</p><ul><li>Can override with <code>gcc -fno-common</code></li></ul></li><li><img src="/2024/051-cmu-15513/linker-puzzle.webp" srcset="/img/loading.gif" lazyload></li></ul><img src="/2024/051-cmu-15513/loading-executable-object-files.webp" srcset="/img/loading.gif" lazyload><h1 id="lec-17-processes-and-multitasking"><a class="markdownIt-Anchor" href="#lec-17-processes-and-multitasking"></a> Lec 17. Processes and Multitasking</h1><h2 id="processes"><a class="markdownIt-Anchor" href="#processes"></a> Processes</h2><p>Definition: an instance of a running program.</p><p>Process provides each program with two key abstractions:</p><ul><li><strong>private address space</strong>: process似乎能占用整块内存 (由virtual memory提供)</li><li><strong>logical control flow</strong>: 似乎能完全占有cpu运行时间 (由context switching提供)</li></ul><p>Processes are managed by <strong>kernel</strong></p><h2 id="system-calls"><a class="markdownIt-Anchor" href="#system-calls"></a> System Calls</h2><p>On error, most system-level functions return -1 and set global variable <code>errno</code></p><p>Prints out<code>strerror(errno)</code> to see cause.</p><h2 id="process-control"><a class="markdownIt-Anchor" href="#process-control"></a> Process Control</h2><p><code>pid_t getpid(void)</code>: 获取当前进程的PID</p><p><code>pid_t getppid(void)</code>: 获取父进程的PID</p><p>任意时刻，一个process是以下四种状态之一</p><ul><li><strong>running</strong></li><li><strong>blocked / sleeping</strong>: 通常是在等IO操作</li><li><strong>stopped</strong>: process prevented from executing by user (ctrl+Z)</li><li><strong>terminated / zombie</strong>: 进程已结束，但父进程还未收到消息。<ul><li>Process become terminated because of 3 reasons<ul><li>receiving a signal whose default action is to terminate</li><li>return from <code>main</code></li><li>calling <code>exit</code></li></ul></li></ul></li></ul><p>Fork</p><ul><li>returns 0 to child, return child’s PID to parent</li><li>child gets copy of parent’s virtual addr space, opened file descriptors.</li></ul><h2 id="reaping-child-process"><a class="markdownIt-Anchor" href="#reaping-child-process"></a> Reaping child process</h2><p>当child terminate的时候仍然会占据系统资源，这个zombine process的exit status和resource storage可能它的父进程还需要，所以会保留。</p><p>Reaping: 如果parent用 <code>waitpid()</code> (对于特定child）, <code>wait()</code> (对于任意child) 来收集子进程的信息。父进程reaping之后(收集子进程信息之后), 子进程才会被cleanup。</p><p>如果父进程结束之后也没有reaping its children，那么一个pid=1 叫做 <code>init</code> 的进程会自动变为父进程。Not a good practice.</p><p>SIGCHID: 当父进程的任意一个子进程发生状态变化时，父进程会收到这个信号。默认行为是忽略。可以更改。</p><p>状态变化：terminates; is stopped by a signal; resumes</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sigchld_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> &#123;<br>	<span class="hljs-type">int</span> status;<br>	<span class="hljs-type">pid_t</span> pid;<br>	<span class="hljs-keyword">while</span> ((pid = waitpid(<span class="hljs-number">-1</span>, &amp;status, WNOHANG)) &gt; <span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-comment">// Handle child termination</span><br>	&#125;<br>&#125;<br>signal(SIGCHLD, sigchld_handler)<br></code></pre></td></tr></table></figure><h2 id="wait-synchronizing-with-children"><a class="markdownIt-Anchor" href="#wait-synchronizing-with-children"></a> wait(): synchronizing with children</h2><ul><li><code>pid_t wait(int *status)</code><ul><li>suspends current (parent) process until one of its children terminates (always waits for the 1st child to terminate)</li><li>returns PID of child, record exit status in <code>status</code><ul><li>status macros defined in <code>sys/wait.h</code>: <code>WIFEXITED</code>, <code>WIFSIGNALED</code>, …</li></ul></li></ul></li><li><code>pid_t waitpid(pid_t pid, int *status, int options)</code><ul><li>wait for a specific child or group of children<ul><li>pid = -1: wait for any child, like <code>wait()</code></li><li>pid = 0: wait for any child in the same process group</li><li>pid &lt; -1: wait for any child in process group |pid|</li><li>pid &gt; 0: specific child</li></ul></li><li>can be told to return immediately if there are no children to reap<ul><li>options = <code>WNOHANG</code>: non-blocking wait. Function returns 0 immediately if no child has terminated yet.</li><li>options = <code>WUNTRACED</code>: report stopped children</li><li>options = <code>WCONTINUED</code>: report continued children</li></ul></li></ul></li></ul><h2 id="execve-loading-and-running-programs"><a class="markdownIt-Anchor" href="#execve-loading-and-running-programs"></a> execve(): loading and running programs</h2><p><code>int execve(char *filename, char *argv[], char *envp[])</code></p><ul><li>loads and runs in the <strong>current</strong> process. <strong>Overwrites</strong> code, data and stack.</li><li><code>envp</code> is the environment variable list, <code>NAME=VALUE</code> strings.</li></ul><h1 id="lec-18-exceptional-control-flow"><a class="markdownIt-Anchor" href="#lec-18-exceptional-control-flow"></a> Lec 18. Exceptional Control Flow</h1><p>Control flow: 一段顺序执行的指令.</p><p>Up to now, two mechanisms for changing control flow: jumps and branches, call and return.</p><p>但不足以应对系统，例如IO操作完成、用户按下键盘按键等。</p><h2 id="exceptional-control-flow"><a class="markdownIt-Anchor" href="#exceptional-control-flow"></a> Exceptional Control Flow</h2><ul><li>(low level) <strong>Exceptions</strong><ul><li>Implemented by HW and OS</li><li>Exception: transfer of control to the OS kernel in response to some event<ul><li>event: e.g. change in processor state (divide by 0, page fault, IO req completes, …)</li></ul></li><li>Exception Tables<ul><li>每种类型的event都有一个独一无二的exception number. 查表得知exception的handler。</li></ul></li><li>可分为 Asychronous 和 Synchronous<ul><li>Asynchronous Exceptions (Interrupts 中断)：例如：timer (每隔几毫秒外部计时器自动触发), 用户按下ctrl-c, IO操作读取完成，等</li><li>Synchronous Exceptions: 由某一条指令的执行结果产生，包括 traps, faults, aborts<ul><li><strong>trap</strong>: Intentional<ul><li>例如system call, GDB断点</li></ul></li><li><strong>faults</strong>: Unintentional, may or may not be recoverable<ul><li>page faults (recoverable), protection faults (unrecoverable)</li></ul></li><li><strong>aborts</strong>: Unintentional, Unrecoverable<ul><li>e.g. 非法指令、机器自检 奇偶校验失败</li></ul></li></ul></li></ul></li></ul></li><li>(higher level) <strong>Process context switch</strong><ul><li>Implemented by hardware timer and OS software</li></ul></li><li>(higher level) <strong>signals</strong><ul><li>Implemented by OS software</li></ul></li><li>(higher level) <strong>Nonlocal jumps</strong>: <code>setjmp()</code> and <code>longjmp()</code><ul><li>Implemented by C runtime library</li></ul></li></ul><h2 id="signals"><a class="markdownIt-Anchor" href="#signals"></a> Signals</h2><p>signal: 通知process的一条消息，表示某种类型的event发生了。</p><ul><li>signal 一定是由kernel发出的（有时是由其它process请求kernel发出）</li><li>kernel发送signal的原因：<ul><li><ol><li>kernel检测到某种系统event，例如除零(SIGFPE)、或者child process停止 (SIGCHLD)</li><li>另一个process通过kill这个syscall请求给某个process发送KILL signal</li></ol></li></ul></li></ul><p>收到signal时必须做出反应</p><ul><li><strong>ignore</strong> the signal: do nothing (例如SIGCHLD的默认操作是ignore)</li><li><strong>terminate</strong> the process</li><li><strong>catch</strong> the signal by executing <strong>signal handler</strong><ul><li>signal handler 由用户指定，执行完signal handler时才去执行下一条本该执行的指令</li></ul></li></ul><p>Pending and Blocked signals</p><ul><li><strong>Pending</strong>: 一个signal已经发出但尚未被收到，则为pending状态<ul><li>任意时刻同种类型的signal只有能有一个处在pending状态。<strong>Signals are not queued</strong>.</li><li>已有某类型signal处在pending状态，如果后续再向process发送同类型signal将会被discard。<strong>A pending signal is received at most once.</strong></li></ul></li><li><strong>Blocked</strong>: 一个process能够block某种类型的signal。被block掉的类型的signal可以发送，但直到被unblock之前process都不会收到。<ul><li>SIGKILL, SIGSTOP 无法被block；SIGSEGV, SIGILL 等 can only be blocked when sent by other processes.</li><li>在进入一个signal handler时，不会被相同类型的signal打扰。例如正在执行SIGINT handler，其无法被另一个SIGINT signal interrupt。</li></ul></li></ul><p>Sending signals: <strong>Process Groups</strong></p><ul><li>每个process只能属于一个process group.<ul><li>pgid = process group id</li><li><code>getpgrp()</code>: get process group of current process</li><li><code>setpgid()</code>: change process group of a process</li></ul></li></ul><h1 id="lec-19-system-level-io"><a class="markdownIt-Anchor" href="#lec-19-system-level-io"></a> Lec 19. System-Level IO</h1><h2 id="unix-io-一切皆文件"><a class="markdownIt-Anchor" href="#unix-io-一切皆文件"></a> Unix I/O: 一切皆文件</h2><ul><li>Kernel 提供了操作文件的基础方法<ul><li><code>open()</code>, <code>close()</code>, <code>read()</code>, <code>write()</code></li><li>找文件信息 (size, type, last modified time, …): <code>stat()</code>, <code>lstat()</code>, <code>fstat()</code></li><li>Changing the <strong>current file position</strong> (<strong>seek</strong>): <code>lseek()</code></li></ul></li><li>Each file has a <strong>type</strong><ul><li>Regular file<ul><li>应用程序一般会区分二进制文件和纯文本文件。Kernel不区分。</li></ul></li><li>Directory<ul><li>由一堆 <strong>entries</strong> (aka <strong>links</strong>) 组成。至少有两个entry: <code>.</code> and <code>..</code></li><li>Kernel mains <strong>current working directory (cwd)</strong> for each process. (modifies by <code>cd</code>)</li></ul></li><li>Socket</li><li>Named pipes (FIFOs)</li><li>Symbolic links</li><li>Character and block devices</li></ul></li></ul><h2 id="openclose-files"><a class="markdownIt-Anchor" href="#openclose-files"></a> Open/Close files</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> fd;<br>fd = open(<span class="hljs-string">&quot;/etc/hosts&quot;</span>, O_RDONLY);<br></code></pre></td></tr></table></figure><p>Returns <strong>file descriptor</strong> (<code>fd == -1</code> indicates error)</p><p>每个process启动时会有三个已经打开的fd:</p><ul><li>0: stdin</li><li>1: stdout</li><li>2: stderr</li><li>These could be files, pipes, terminal, or even a network connection</li></ul><p>Ways to call <code>open()</code></p><p>open可以传两个参数也可以传三个参数。<code>O_CREAT</code> 必须传第三个参数，其余情况第三个参数会被忽略。</p><ul><li>打开已经存在的文件: <code>open(path, flags)</code><ul><li>flags必须也只能包含以下三个中的一个: <code>O_RDONLY</code>, <code>O_WRONLY</code>, <code>O_RDWR</code></li><li>flags也可以包含: <code>O_APPEND</code>, <code>O_TRUNC</code> (delete existing contents if any), <code>O_CLOEXEC</code> (close this file if execve is called) 等等</li></ul></li><li>打开或创建文件: <code>open(path, flags, mode)</code><ul><li>flags必须包含 <code>O_CREAT</code> 和 <code>O_WRONLY</code>, <code>O_RDWR</code> 这两个中的一个。</li><li>flags也可以包含: <code>O_EXCL</code> (fail if file does exist), <code>O_APPEND</code>, <code>O_TRUNC</code>, <code>O_CLOEXEC</code> 等</li></ul></li><li>Third argument gives default access permissions for newly created files.<ul><li>Use <code>DEFFILEMODE</code> unless you have a specific reason to want something else.</li></ul></li></ul><p>Closing files</p><ul><li>do not close any file more than once</li><li>closing can fail. The file is still closed. The OS is taking this opportunity to report a delayed error from a previous write operation.</li></ul><h2 id="readwrite-files"><a class="markdownIt-Anchor" href="#readwrite-files"></a> Read/Write files</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>];<br><span class="hljs-type">int</span> fd;<br><span class="hljs-type">int</span> nbytes;<br><br><span class="hljs-keyword">if</span> ((nbytes = read(fd, buf, <span class="hljs-keyword">sizeof</span>(buf))) &lt; <span class="hljs-number">0</span>) &#123;<br>	perror(<span class="hljs-string">&quot;read&quot;</span>);<br>	<span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>Returns number of bytes read. (return type <code>ssize_t</code> is signed integer, <code>nbytes &lt; 0</code> indicates error)</p><p><strong>short counts</strong> (<code>nbytes</code> &lt; <code>sizeof(buf)</code>) are possible, and are not errors!</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>];<br><span class="hljs-type">int</span> fd; <br><span class="hljs-type">int</span> nbytes; <br><br><span class="hljs-keyword">if</span> ((nbytes = write(fd, buf, <span class="hljs-keyword">sizeof</span>(buf)) &lt; <span class="hljs-number">0</span>) &#123;<br>	perror(<span class="hljs-string">&quot;write&quot;</span>);<br>	<span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>Similarly, <strong>short counts</strong> are possible and are not errors.</p><h3 id="short-counts"><a class="markdownIt-Anchor" href="#short-counts"></a> Short counts</h3><p>Short counts can occur in</p><ul><li>encountering EOF on reads</li><li>reading text lines from terminal</li><li>read and write network sockets, pipes, etc.</li></ul><p>Short counts never occur in</p><ul><li>reading from disk files (except for EOF)</li><li>writing to disk files</li></ul><p>Best practice is to always allow for short counts.</p><h2 id="standard-io"><a class="markdownIt-Anchor" href="#standard-io"></a> Standard IO</h2><ul><li>unix io: <code>open</code>, <code>close</code>, <code>read</code>, <code>write</code></li><li>standard io: <code>fopen</code>, <code>fclose</code>, <code>fread</code>, <code>fwrite</code>, <code>fgets</code>, <code>fputs</code>, <code>fscanf</code>, <code>fprintf</code></li></ul><p>Standard IO open files as <strong>streams</strong> (abstraction for fd)</p><p>C program begins with three open streams (defined in <code>stdio.h</code>):</p><ul><li><code>extern FILE *stdin</code></li><li><code>extern FILE *stdout</code></li><li><code>extern FILE *stderr</code></li></ul><p>Buffered IO: motivation</p><ul><li>Applications often read/write 1 char at a time<ul><li><code>getc</code>, <code>putc</code>, <code>ungetc</code></li><li><code>gets</code>, <code>fgets</code> (read line of text 1 char at a time, stop at newline)</li></ul></li><li>Unix IO calls are expensive (<code>read</code> and <code>write</code> requires unix kernel calls, &gt;10000 clock cycles)</li><li>Solution: <strong>Buffered IO</strong></li><li>Buffered read</li><li>Buffered write: buffer flushed to output fd on <code>\n</code> or call to <code>fflush</code> or <code>exit</code> or return from <code>main</code>.</li></ul><h2 id="which-io-when"><a class="markdownIt-Anchor" href="#which-io-when"></a> Which IO when</h2><p><strong>Unix IO Pros</strong></p><ul><li>most general. All other IO packages are using it.</li><li>can access file metadata</li><li>async-signal-safe and can be used safely in signal handlers</li></ul><p><strong>Unix IO Cons</strong></p><ul><li>Dealing with short counts is tricky and error prone</li><li>Efficient reading requires buffering, which is also tricky and error prone</li></ul><p><strong>Std IO Pros</strong></p><ul><li>Buffering increases efficiency</li><li>short counts handled automatically</li></ul><p><strong>Std IO Cons</strong></p><ul><li>no function for accessing file metadata</li><li>not async-signal-safe</li><li>not appropriate for io on network sockets</li></ul><p>Aside: never use the following on binary files:</p><ul><li>Text-oriented IO: <code>fgets</code>, <code>scanf</code>, <code>rio_readlineb</code>, …</li><li>String functions: <code>strlen</code>, <code>strcpy</code>, <code>strcat</code>, …</li></ul><h2 id="metadata-sharing-and-redirection"><a class="markdownIt-Anchor" href="#metadata-sharing-and-redirection"></a> Metadata, sharing and redirection</h2><p>Metadata maintained for each file. Access with <code>stat</code> and <code>fstat</code>.</p><p>File sharing: two open file table points to the same v-node table</p><img src="/2024/051-cmu-15513/file-sharing.webp" srcset="/img/loading.gif" lazyload><p><strong>Fork</strong>: child’s open file table inherits parent. refcnt++.</p><p><strong>IO Redirection</strong>: <code>dup2(oldfd, newfd)</code>.</p><h1 id="lec-20-network-programming"><a class="markdownIt-Anchor" href="#lec-20-network-programming"></a> Lec 20. Network Programming</h1><p><strong>network</strong>:</p><ul><li>LAN (local area network), spans a building or campus</li><li>WAN (wide area network), spans country or world</li><li>Also SAN (storage area network), …</li></ul><p><strong>Internet Protocol</strong> (Protocol is a set of rules)</p><ul><li>provides a <strong>naming scheme</strong>.<ul><li>defines a uniform format for <strong>host addresses</strong>.</li><li>each host (and router) is assigned at least 1 of these unique address.</li></ul></li><li>provides a <strong>delivery mechanism</strong><ul><li>defines a standard transfer unit (<strong>packet</strong>)</li><li>packet consists of <strong>header</strong> and <strong>payload</strong></li></ul></li></ul><p>The <strong>Global IP Internet</strong> (大写I) is the most famous example of an <strong>internet</strong> (小写i).</p><h2 id="global-ip-internet-upper-case-i"><a class="markdownIt-Anchor" href="#global-ip-internet-upper-case-i"></a> Global IP Internet (upper case I)</h2><p>based on TCP/IP protocol family</p><ul><li><strong>IP</strong> (Internet Protocol)<ul><li>provides basic naming scheme, unreliable delivery capability from <strong>host-to-host</strong></li></ul></li><li><strong>UDP</strong> (User Datagram Protocol)<ul><li>Uses IP to provide <strong>unreliable</strong> datagram delivery from <strong>process-to-process</strong></li></ul></li><li><strong>TCP</strong> (Transmission Control Protocol)<ul><li>Uses IP to provide <strong>reliable</strong> byte streams from <strong>process-to-process</strong></li></ul></li></ul><p>Accessed via <strong>sockets interface</strong> (a mix of Unix file IO and functions)</p><h2 id="dns-domain-naming-system"><a class="markdownIt-Anchor" href="#dns-domain-naming-system"></a> DNS (domain naming system)</h2><p>32-bit IP address, always stored in memory in <strong>network byte order</strong> (big endian byte order)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> &#123;</span><br>	<span class="hljs-type">uint32_t</span> s_addr;  <span class="hljs-comment">// network byte order (big-endian)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>use <code>getaddrinfo</code> and <code>getnameinfo</code> to convert between IP and dooted decimal format.</p><p>DNS: mapping between IP and domain names.</p><p><code>nslookup</code>: see the mapping</p><ul><li>多个域名可以指向同一个IP。</li><li>有效域名可以不指向任何IP。</li></ul><p>TCP connections:</p><ul><li>Point-to-point: connects a pair of processes</li><li><strong>Full-duplex</strong>: 数据在同一时刻能够双向传输</li><li><strong>Reliable</strong>: 数据发送顺序和接收顺序一样</li></ul><p>A <strong>socket</strong> is an endpoint of a connection (socket addr is <code>IPaddress:port</code> pair)</p><p>A port is a 16-bit integer that identifies a process</p><ul><li>Ephemeral port: assigned automatically by client kernel</li><li>Well-known port: e.g. 80 is for web servers.<ul><li><code>/etc/services</code> 中列出了这些well-known ports</li></ul></li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Lecture-Notes/" class="category-chain-item">Lecture Notes</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/C/" class="print-no-link">#C</a> <a href="/tags/Lecture-Notes/" class="print-no-link">#Lecture Notes</a></div></div><div class="license-box my-3"><div class="license-title"><div>[Lecture Notes] CMU 15-513 Intro to Computer Systems</div><div>https://www.billhu.us/2024/051-cmu-15513/</div></div><div class="license-meta"><div class="license-meta-item"><div>Author</div><div>Bill Hu</div></div><div class="license-meta-item license-meta-date"><div>Posted on</div><div>September 3, 2024</div></div><div class="license-meta-item"><div>Licensed under</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - Attribution"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2025/054_cmu_15618/" title="[Lecture Notes] CMU 15-618 Parallel Computer Architecture &amp; Programming"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">[Lecture Notes] CMU 15-618 Parallel Computer Architecture &amp; Programming</span> <span class="visible-mobile">Previous</span></a></article><article class="post-next col-6"><a href="/2024/053_cmu_15721/" title="[Lecture Notes] CMU 15-721 Advanced Database"><span class="hidden-mobile">[Lecture Notes] CMU 15-721 Advanced Database</span> <span class="visible-mobile">Next</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>Table of Contents</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">Search</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">Keyword</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <span>With </span><a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <i class="iconfont icon-love"></i> <a href="/about" target="_blank" rel="nofollow noopener"><span>Bill Hu</span></a><div style="font-size:.85rem"><span id="timeDate">Loading days...</span> <span id="times">Loading time...</span><script src="/js/duration.min.js"></script></div></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,t=t.getElementById("subtitle");t&&e&&e(t.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){var t;"tocbot"in window&&(tocbot.refresh(),0!==(t=jQuery("#toc")).length)&&tocbot&&0<t.find(".toc-list-item").length&&t.css("visibility","visible")}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback(function(){if("anchors"in window){anchors.removeAll();var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}})})</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">Blog works best with JavaScript enabled</div></noscript></body></html>