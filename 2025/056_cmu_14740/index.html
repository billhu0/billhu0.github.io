<!DOCTYPE html><html lang="en" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Bill Hu"><meta name="keywords" content=""><meta name="description" content="CMU 14-740 Notes: Fundamentals of Telecommunication Networks"><meta property="og:type" content="article"><meta property="og:title" content="[Lecture Notes] CMU 14-740 Fundamentals of Telecommunication Networks"><meta property="og:url" content="https://www.billhu.us/2025/056_cmu_14740/index.html"><meta property="og:site_name" content="Bill Hu&#39;s Blog"><meta property="og:description" content="CMU 14-740 Notes: Fundamentals of Telecommunication Networks"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/tcp-layers.png"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/encapsulation.png"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/ip-hourglass-design.png"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/peer-transit.png"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/non-persistent-http.png"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/persistent-http-pipelining.png"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/server-push.png"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/dns-query-navigation.png"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/zone-nameserver.png"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/dns-hierarchy.png"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/bootstraping-in-gnutella.png"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/locate-content.png"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/encapsulation-layers.png"><meta property="article:published_time" content="2025-01-16T19:17:06.000Z"><meta property="article:modified_time" content="2025-02-06T18:07:09.506Z"><meta property="article:author" content="Bill Hu"><meta property="article:tag" content="Lecture Notes"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://www.billhu.us/2025/056_cmu_14740/tcp-layers.png"><title>[Lecture Notes] CMU 14-740 Fundamentals of Telecommunication Networks - Bill Hu&#39;s Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.15.6/katex.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/myfont.css"><link rel="stylesheet" href="/css/jetbrains-mono.css"><script id="fluid-configs">var dntVal,Fluid=window.Fluid||{},CONFIG=(Fluid.ctx=Object.assign({},Fluid.ctx),{hostname:"www.billhu.us",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:25,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:3},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},gtag:null},search_path:"/local-search.xml",include_content_in_search:!0});CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script>!function(t,e,n,c,a,r){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(a=e.createElement(c)).async=1,a.src="https://www.clarity.ms/tag/fjnxcr4gva",(r=e.getElementsByTagName(c)[0]).parentNode.insertBefore(a,r)}(window,document,"clarity","script")</script><meta name="google-site-verification" content="IqNfw3GiMxuhw7kYoEdhMJoh3j99KHuGI9bw00hPn2c"><link href="https://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Kaushan+Script" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic,700italic" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto+Slab:400,100,300,700" rel="stylesheet"><meta name="generator" content="Hexo 7.1.1"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Bill Hu&#39;s Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>Home</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>Archives</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>Categories</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>Tags</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>About</span></a></li><li class="nav-item"><a class="nav-link" href="https://www.billhu.xyz" target="_self"><i class="iconfont icon-code"></i> <span>Portfolio</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="[Lecture Notes] CMU 14-740 Fundamentals of Telecommunication Networks"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2025-01-16 19:17" pubdate>January 16, 2025 pm</time></span></div><div class="mt-1"></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">[Lecture Notes] CMU 14-740 Fundamentals of Telecommunication Networks</h1><div class="markdown-body"><h1 id="lec-1-intro"><a class="markdownIt-Anchor" href="#lec-1-intro"></a> Lec 1. Intro</h1><p>Network <strong>Protocols</strong>: Define the <strong>format</strong> (of a message), <strong>order</strong> of messages sent and received among network entities, and <strong>actions</strong> taken on message transmission or receipt.</p><p>所有Internet的通信活动都由protocol管。</p><p>Reliable: 发送到的和接收到的数据一致，顺序一致。要reliable就会有overhead，需要trade-off.</p><ul><li><strong>circuit switching</strong><ul><li>每一个connection都由一个channel, <strong>connection-oriented</strong></li><li>在没有connection/call/user使用的时候会导致资源浪费</li><li>每一个信号都有time和frequency，同一时刻有不同频率的信号频段都可以传输。如何切分？<ul><li><strong>FDM</strong> (Frequency Division Multiplexing) 频分复用</li><li><strong>TDM</strong> (Time Division Multiplexing) 时分复用</li></ul></li></ul></li><li><strong>packet switching</strong><ul><li><strong>Connectionless</strong>, 没有channel，用多个paths</li><li>数据切分成小块，称为packets</li><li>所有用户都可以使用完整的带宽，没有FDM、TDM等，<strong>statistical sharing</strong></li><li><strong>Store and forward model</strong>: 一条link上有好多个节点，节点必须接收到完整packet才会继续发送给下一个节点</li><li>缺点是会有congestion，数据包太多会导致竞争</li></ul></li></ul><h1 id="lec-2-architecture"><a class="markdownIt-Anchor" href="#lec-2-architecture"></a> Lec 2. Architecture</h1><p>packet switching: 每一个packet都能占用全部的bandwidth，需要<strong>queue</strong></p><p>如果queue满了，新的packet会被<strong>drop</strong>（aka lost, 丢包）</p><hr><p>4 Sources of packet delay</p><ul><li><strong>processing delay</strong> (nodal processing)<ul><li>Router接收到packet时需要：①检查bit errors ②决定转发给谁</li><li>与router的处理速度有关</li></ul></li><li><strong>queueing delay</strong><ul><li>router一次只能发一个packet，需要排队等待</li><li>与router的congestion level （拥堵情况）、buffer size都有关</li><li>范围可以从0到无穷（无穷代表丢包）</li><li>Traffic intensity <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi><mo>=</mo><mi>L</mi><mo>×</mo><mi>λ</mi><mi mathvariant="normal">/</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">\rho = L \times \lambda / R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">ρ</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.76666em;vertical-align:-.08333em"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">λ</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:.00773em">R</span></span></span></span> (=输入除以输出)<ul><li>L = Packet Length (bits/pkt)</li><li>R = Link Speed / Data Rate (bps)</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">λ</span></span></span></span> = Average Packet Arrival Rate (pkt/s)</li></ul></li></ul></li><li><strong>transmission delay</strong><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">T_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.2805559999999999em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi mathvariant="normal">/</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">L/R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">L</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:.00773em">R</span></span></span></span> = Packet Length / Link Bandwidth</li></ul></li><li><strong>propagation delay</strong><ul><li>第一个bit发送需要的延迟时间。取决于光速（或物理介质速度）</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>p</mi></msub><mo>=</mo><mi>d</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">T_p = d / s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.969438em;vertical-align:-.286108em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.15139200000000003em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">d</span><span class="mord">/</span><span class="mord mathnormal">s</span></span></span></span> = Length of physical link / Propagation speed in physical medium</li></ul></li></ul><p>Traceroute：发送给第i个node来回的时间</p><hr><p>Layered Network Architecture</p><ul><li><p>Layer的优点</p><ul><li>每个layer里面的protocol可以分开设计，互不干扰，简化设计、实现和测试流程</li></ul></li><li><p>Layer的缺点</p><ul><li>duplication：每个layer都做了一些reliability的设计，导致重复</li><li>每层layer之间隐藏了信息，可能影响性能（完成某些操作可能需要底层layer的信息）</li></ul></li><li><p><strong>ISO OSI</strong> reference model / <strong>TCP/IP</strong></p><ul><li><p>1970s的时候不同的网络架构互不兼容，无法互相通信，所以ISO搞出了OSI来实现 <strong>interoperability</strong></p></li><li><p>ISO: International Standard Organization</p></li><li><p>OSI: Open Systems Interconnection</p></li><li><p>然后 TCP/IP 把OSI protocol给取代了</p></li><li><p>OSI有7层layer，TCP/IP有5层layer。顶上两个是end-to-end，底下的是hop-by-hop.</p><img src="/2025/056_cmu_14740/tcp-layers.png" srcset="/img/loading.gif" lazyload></li></ul></li></ul><h1 id="lec-3-design-principles"><a class="markdownIt-Anchor" href="#lec-3-design-principles"></a> Lec 3. Design Principles</h1><h2 id="virtual-connections"><a class="markdownIt-Anchor" href="#virtual-connections"></a> Virtual connections</h2><p>每层layer都有自己的header。</p><p><strong>Encapsulation</strong>: Sending host, 从更高层layer获取信息，在payload前加一个自己的header</p><p><strong>Decapsulation</strong>: Receiving host, 从更底层layer获取信息，从自己的header提取信息然后去掉</p><img src="/2025/056_cmu_14740/encapsulation.png" srcset="/img/loading.gif" lazyload><h2 id="tcpip"><a class="markdownIt-Anchor" href="#tcpip"></a> TCP/IP</h2><img src="/2025/056_cmu_14740/ip-hourglass-design.png" srcset="/img/loading.gif" lazyload><ul><li><p>“<strong>Hourglass</strong>” design, IP 是最中间的glue，IP的上层和下层都有很多东西</p><p>缺点：IP至关重要，并且改IP很困难，像IPv4到IPv6的迁移非常复杂。</p></li><li><p><strong>No Strict layering</strong>: 应用程序也可以绕过layer直接用底层。</p></li><li><p>协议需要 <strong>standardized</strong>.</p><ul><li>Internet Engineering Task Force (IETF). 每个IETF标准都公开发布了Request for Comments (RFC).</li><li>但不是所有RFC都成为了标准。RFC包含实验性的协议</li></ul></li></ul><h2 id="goals-of-tcpip-design"><a class="markdownIt-Anchor" href="#goals-of-tcpip-design"></a> Goals of TCP/IP design</h2><p>Clark88论文</p><ul><li><strong>Fundamental goal</strong>: 把现有的网络给interconnect起来。使用 store-and-forward packet-switching 方法，用 gateways 连接起来.</li><li><strong>Second level goals</strong>:<ul><li>continue despite failures 失败了也要继续（失败了要重建连接）<ul><li>需要保存state(状态信息)，这样连接中断了才能重新建立连接</li><li>state是存在intermediate nodes还是存在end-hosts? 存在end-hosts里。<strong>stateless nodes</strong>.</li></ul></li><li>支持多种服务<ul><li>TCP: <strong>Connection-oriented</strong>; UDP: <strong>connectionless</strong></li><li>最初TCP的目标是connection-oriented and reliable。Reliability是主要的延迟来源。所以TCP和IP分离了，搞了个UDP。</li></ul></li><li>支持多种网络技术（有线网、无线电等）</li><li>distributed management 自己需要能管理自己的网络<ul><li>networks can be administered separately</li></ul></li><li>cost-effective 效率</li><li>account for resources used<ul><li>早期设计的时候没有人在意（现在很多人在意网速）。</li></ul></li><li>上述后两个目标并没有获得太多attention甚至完全没有被考虑过</li></ul></li></ul><h1 id="lec-4-internet-isps-architecture"><a class="markdownIt-Anchor" href="#lec-4-internet-isps-architecture"></a> Lec 4. Internet ISP’s Architecture</h1><p>The Internet is a <strong>Network of Networks</strong>.</p><p>ISP: <strong>Internet Service Provider</strong></p><p>A <strong>backbone</strong> network ISP: 能够让所有customers连接到全球网络</p><ul><li>最早的时候只有一个backbone ISP叫做 <code>NSFNET</code></li><li>但是这样做不好，比如有两个中国电脑通信，仍然需要经过位于美国的全球唯一backbone</li><li>所以出现了多个 commercial backbone ISP 互相interconnect来实现全球互联网连接</li></ul><h2 id="transit-peering"><a class="markdownIt-Anchor" href="#transit-peering"></a> Transit &amp; Peering</h2><p><strong>Transit</strong> interface: 一个backbone ISP将网络传输服务售卖给客户（“客户”指更小的ISP或别的大企业）</p><p><strong>Peering</strong> interface: ISP之间互相直接访问</p><ul><li>peering通常是免费的，互惠互利，数据直接传输，不经过transit provider</li><li>peering的关系通常是商业机密</li></ul><h2 id="different-types-of-isp"><a class="markdownIt-Anchor" href="#different-types-of-isp"></a> Different types of ISP</h2><p><strong>Tier-1</strong>：</p><ul><li>Tier-1的定义已经被滥用，每个ISP都自称自己是Tier-1。通常Tier-1指的是：<ul><li>① 和一大堆customer有 <strong>transit</strong> link</li><li>② 和一大堆别的Tier-1 backbone ISP有 <strong>peering</strong> (business) interconnections. (通常有 <strong>full-mesh</strong> architecture)</li></ul></li><li>Tier-1网速快，延迟低，全球都有，与很多Tier-2 ISP相连（Tier-2 ISP是Tier-1 ISP的transit customers)</li><li>Tier-1不需要从别的ISP购买transit就可以访问到全球互联网</li><li>Tier-1 ISP通常有一种 <strong>restrictive peering policy</strong><ul><li>不要轻易跟别的非Tier-1 ISP去peer，因为它们是潜在的客户，要向它们收钱</li></ul></li></ul><p><strong>Tier-2</strong>:</p><ul><li>通常来说，不是 Tier-1 的ISP就叫做 Tier-2.</li><li>Tier-2需要从Tier-1 ISP购买transit access</li><li>Tier-2向更下层的客户提供付费transit服务</li><li>Tier-2和Tier-2之间也会peer。通常有一种 <strong>open-peering policy</strong><ul><li>Tier-2要和尽可能多的ISP去peer</li><li>需要权衡一下成本：Peer会产生 <strong>management cost</strong> 和 <strong>maintenance cost</strong></li></ul></li></ul><img src="/2025/056_cmu_14740/peer-transit.png" srcset="/img/loading.gif" lazyload><p>这几年有个新东西进入了ISP体系结构：<strong>Content Providers</strong> (Large Enterprise Companies)</p><p><strong>Content Providers</strong></p><ul><li>Do not sell transit.</li><li>可分为以下两类<ul><li>Category A: Focus on content creation<ul><li>不peering，不运作网络</li></ul></li><li>Category B: Sophisticated, large-scale players<ul><li>open peering policy</li></ul></li></ul></li></ul><h1 id="lec-5-application-layer-http"><a class="markdownIt-Anchor" href="#lec-5-application-layer-http"></a> Lec 5. Application Layer &amp; HTTP</h1><p>Application Layer <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">≠</mo></mrow><annotation encoding="application/x-tex">\neq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span></span></span></span> User Application</p><p>Application Layer provides Services (e.g. SMTP, HTTP, FTP, SSH)</p><p>许多Application Layer Services需要先创建一个<strong>Transport Layer</strong> (TL) <strong>connection</strong> (channel).</p><h2 id="http"><a class="markdownIt-Anchor" href="#http"></a> HTTP</h2><p><strong>HTTP-message</strong> 由 <strong>request</strong> 或 <strong>response</strong> 组成</p><p>Request或Response由 <strong>start line</strong>, <strong>header</strong>, <strong>empty line</strong> 和 <strong>message body</strong> 组成</p><ul><li><p><strong>Start line</strong>: <code>Request-line</code> 或 <code>Status-line</code></p><ul><li><p><code>Request-line</code> = <code>Method</code> sp <code>Request-URI</code> sp <code>HTTP-Version</code> CRLF</p><p>e.g. <code>GET /images/logos.html HTTP/1.1</code></p><p>Method包含 <code>GET</code>, <code>POST</code>, <code>HEAD</code>, <code>PUT</code>, <code>DELETE</code></p><p>Method中的<code>GET</code>:</p><ul><li><strong>conditional <code>GET</code></strong>: <code>If-Modified-Since</code>, <code>If-Match</code></li><li><strong>partial <code>GET</code></strong>: 只获取一个object的指定byte范围。header中包含<code>RANGE</code> field。</li></ul><p>Method中的 <code>HEAD</code>: 获取metadata（与GET相同，但不包含message body）</p><p>Method中的 <code>OPTIONS</code>: 获取服务器或资源的能力，不获取资源本身</p></li><li><p><code>Status-line</code> = <code>HTTP-version</code> sp <code>Status-Code</code> sp <code>Reason-Phrase</code> CRLF</p><p>e.g. <code>HTTP/1.1 200 OK\r\n Connection: close...</code></p><p>Status code 是三位数字：</p><ul><li><code>1xx</code>: informational: 请求已收到，正在处理</li><li><code>2xx</code>: success 成功</li><li><code>3xx</code>: redirection 重定向/完成请求需要更多操作</li><li><code>4xx</code>: client error 因为client的错误导致请求格式错误或无法满足请求</li><li><code>5xx</code>: server error 请求完全正确，但服务器原因导致无法满足请求 (e.g. <code>505 HTTP Version Not Supported</code>)</li></ul></li></ul></li><li><p>0个或多个<strong>headers</strong> (<strong>General, Request, or Entity headers</strong>)</p><ul><li>e.g. <code>User-agent: mozilla/5.0... \r\n Connection: close</code></li><li>Header包含HTTP request/response的 <strong>metadata</strong><ul><li>日期，时间，Application或服务器信息，缓存控制，46个有定义的header</li></ul></li><li>HTTP Request 需要 <code>HOST</code> 这一项（Response不需要）</li></ul></li><li><p>空行 (CRLF)</p><p>空行是为了把header和body区分开</p></li><li><p>message body (optional)</p></li></ul><h2 id="persistent-non-persistent-connections"><a class="markdownIt-Anchor" href="#persistent-non-persistent-connections"></a> Persistent &amp; Non-persistent Connections</h2><p>HTTP用TCP作为Transport Layer Protocol</p><p>(TCP在Transport层，HTTP在Application层)</p><p>建立一个HTTP连接需要先建立TCP连接</p><p><strong>Round Trip Time (RTT)</strong>: 发送一条消息并得到回复的所需时间</p><ul><li><p><strong>Non-persistent HTTP</strong></p><p>需要1个RTT建立TCP连接，1个RTT建立HTTP连接，然后传数据，最后1个RTT关闭连接</p><p>Total Transmission Time = 2RTT + file transmit time</p><p>Total Time (包括关闭连接) = 3RTT + file transmit time</p><img src="/2025/056_cmu_14740/non-persistent-http.png" srcset="/img/loading.gif" lazyload></li><li><p><strong>Persistent HTTP</strong></p><ul><li><p>① <strong>Reuse existing TCP connection</strong></p><p>传数据之后不要关闭TCP connection，省去下一次建立TCP连接的时间</p></li><li><p>② <strong>Pipelining</strong> at the Application Layer level</p><p>不等到上一个(HTTP)请求收到回复，就发送下一个request。服务器按照顺序发送数据包。这样所有object最少只需要占用1个RTT</p><p>HTTP/1.1默认使用这样的 Persistent HTTP + Pipelining</p><img src="/2025/056_cmu_14740/persistent-http-pipelining.png" srcset="/img/loading.gif" lazyload></li><li><p><strong>Server Push</strong> in HTTP 2.0</p><p>服务器提前把client会用到的objects主动发过来，不需要client去请求</p><img src="/2025/056_cmu_14740/server-push.png" srcset="/img/loading.gif" lazyload></li></ul></li></ul><h2 id="caching"><a class="markdownIt-Anchor" href="#caching"></a> Caching</h2><ul><li><p><strong>Web Proxy Caching</strong></p><p>建立一个中转代理 <strong>Local Cache</strong> (aka <strong>Local Web Proxy</strong>)</p></li><li><p><strong>File Validation</strong> in HTTP Caching</p><p>HTTP会想办法确保cache是否valid（cache的文件有没有过期）</p><p>有两种 <strong>Cache Expiration Model</strong></p><ul><li><p><strong>Origin Server-specified expiration</strong></p><p>服务器使用 <code>Expires</code> 或 <code>max-age</code> header 直接告诉文件多久后过期</p></li><li><p><strong>Heuristic expiration</strong></p><p>服务器不给定过期时间，client请求资源时用 <code>If-modified-since</code> header，问服务器“我手里的资源是否fresh有没有过期？”</p><p>如果资源过期则发送，资源没过期则用 304 Not Modified 避免重新传输。</p></li></ul></li></ul><h1 id="lec-6-dns"><a class="markdownIt-Anchor" href="#lec-6-dns"></a> Lec 6. DNS</h1><h2 id="dns-services-dns作用"><a class="markdownIt-Anchor" href="#dns-services-dns作用"></a> DNS services (DNS作用)</h2><ul><li><strong>Domain</strong> 与 <strong>IP address</strong> 的转换</li><li><strong>Host aliasing</strong> (alias 和 canonical domain names 的转换)</li><li><strong>Mail Server aliasing</strong> (MX - Mail Exchange)</li><li><strong>Load distribution across Name Servers</strong> (一个域名轮换指向多个服务器)</li></ul><h2 id="dns-protocol"><a class="markdownIt-Anchor" href="#dns-protocol"></a> DNS Protocol</h2><p><strong>Query</strong> and <strong>Reply</strong> (和HTTP类似)</p><ul><li>query和reply用同样的消息格式：<strong>Resource Record (RR)</strong></li><li>每个**Resource Record (RR)**由五部分组成：<code>(Name, Value, Type, Class, TTL)</code></li><li><code>Name</code>: 由RR中的<code>Type</code>决定</li><li><code>Value</code>: e.g. 对于A解析，value是IP地址；对于CNAME解析，value是另一个域名</li><li><code>Type</code>: e.g. <code>A</code>, <code>CNAME</code> 等<ul><li><code>A</code>: Address 指向IPv4地址，<code>AAAA</code> 指向IPv6地址</li><li><code>NS</code>: Nameserver: 指向Authoritative (organization) Name Server，例如cmu有自己的DNS，<a target="_blank" rel="noopener" href="http://Name=cmu.edu">Name=cmu.edu</a>, <a target="_blank" rel="noopener" href="http://Value=dns.cmu.edu">Value=dns.cmu.edu</a></li><li><code>CNAME</code>: Canonical Name</li><li><code>MX</code>: Mail Exchange 指向邮件服务器的hostname</li></ul></li><li><code>Class</code>: 通常全都是 <code>IN</code> 意为Internet</li><li><code>TTL</code>: Time to live 代表这一条RR能被缓存多久，0代表不能缓存</li></ul><p>DNS queries 在<strong>53</strong>号端口上用<strong>UDP</strong>运行</p><ul><li>Exception：在①Zone transfer②大于512字节的response 时会使用TCP</li><li>为什么用UDP？因为TCP的overhead通常比整个DNS query都要大</li></ul><h2 id="navigation"><a class="markdownIt-Anchor" href="#navigation"></a> <strong>Navigation</strong></h2><p>Client可能需要问多个Name Servers (NS)</p><p>每个Name Server返回指向下一个NS的指针（不止返回NS record，也另外返回一个指向另一个NS的A record）</p><ul><li><strong>Non-recursive</strong> (右上图片) 有时也叫 <strong>Iterative</strong></li><li><strong>Recursive</strong> (右下图片)</li></ul><img src="/2025/056_cmu_14740/dns-query-navigation.png" srcset="/img/loading.gif" lazyload><p><strong>DNS caching</strong></p><ul><li>Name Server (NS) 会缓存DNS mapping</li><li>由TTL决定cache多久</li><li>Local Name Servers (Resolves) 通常缓存Top Level Domain (TLD) servers的IP地址</li></ul><h2 id="dns-name-server-hierarchy"><a class="markdownIt-Anchor" href="#dns-name-server-hierarchy"></a> <strong>DNS Name Server Hierarchy</strong></h2><ul><li><p>1 <strong>Root</strong> (root name servers)</p></li><li><p>2 <strong>Top-Level Domain (TLD</strong> Name servers)</p></li><li><p>3 <strong>Authoritative</strong> (e.g. cmu name servers)</p></li><li><p><strong>delegated administrative structure</strong>:</p><ul><li><p>delegated指域名是反着来的 e.g. <a target="_blank" rel="noopener" href="http://library.cmu.edu">library.cmu.edu</a></p></li><li><p>administrative authority 不一定和 <strong>namespace hierarchy</strong>相符</p><p>e.g. cs.cmu.edu有自己的name server, drama.cmu.edu没有</p></li></ul></li><li><p><strong>Zones</strong></p><ul><li><p>namespace hierarchy被分成一个一个zones</p></li><li><p>每一个zone有一个name server</p></li><li><p>zone owner必须：maintain zone data; run redundant name servers (for backup)</p><img src="/2025/056_cmu_14740/zone-nameserver.png" srcset="/img/loading.gif" lazyload></li><li><p><strong>Root Name Server</strong> 知道所有TLD nameserver和它们的地址</p><ul><li>一共只有13个root server，标记为a到m</li></ul></li><li><p><strong>TLD</strong> （e.g. .com, .org, .net）</p><ul><li>由 IANA (Internet Assigned Number Authority) 管理</li><li>TLD NS知道它自己所有域名的所有authoritative (or intermediate) name server的地址</li></ul></li><li><p><strong>Authoritative NS</strong></p></li><li><p><strong>Local Name Server</strong> (DNS Resolver) 也叫 <strong>Default Name Server or Resolver</strong></p><ul><li>并不严格属于DNS结构</li><li>每个organization（公司、学校等）都有一个</li><li>Act as a proxy</li></ul></li></ul></li></ul><img src="/2025/056_cmu_14740/dns-hierarchy.png" srcset="/img/loading.gif" lazyload><h1 id="lec-7-p2p"><a class="markdownIt-Anchor" href="#lec-7-p2p"></a> Lec 7. P2P</h1><p>P2P: Peer-to-peer</p><h2 id="napster-centralized-p2p"><a class="markdownIt-Anchor" href="#napster-centralized-p2p"></a> Napster (Centralized P2P)</h2><p>Napster曾经是第一个p2p music-sharing应用</p><ul><li><p><strong>Centralized</strong>: clients存储文件, 中央server只存储peer信息: <code>&lt;file name, ip address, port number&gt;</code></p></li><li><p>虽然传文件是decentralized，但是定位文件是highly centralized</p></li><li><p>==&gt; 导致的问题: 中央服务器稳定性、中央服务器性能瓶颈</p></li></ul><h2 id="gnutella-distributed-p2p"><a class="markdownIt-Anchor" href="#gnutella-distributed-p2p"></a> Gnutella (Distributed P2P)</h2><ul><li><p>Fully <strong>decentralized (distributed)</strong></p><p>不需要中心的服务器，用户们自己安排自己</p></li><li><p><strong>Not scalable</strong></p><ul><li>fully distributed <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">≠</mo></mrow><annotation encoding="application/x-tex">\neq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span></span></span></span> scalable</li></ul></li><li><p><strong>Bootstraping</strong></p><p>Find peers的方法：每个节点<strong>relay</strong> <strong>ping/pong</strong> messages</p><p>这样每个节点都能得到所有bootstrap nodes的列表</p><img src="/2025/056_cmu_14740/bootstraping-in-gnutella.png" srcset="/img/loading.gif" lazyload></li><li><p>Locate content: <strong>query flooding</strong></p><ul><li><p>节点从现有的TCP连接发出<code>Query</code>消息，相连的Node会relay</p></li><li><p><code>QueryHit</code> 消息会沿着反向路径发出</p></li><li><p>为什么reverse path发送而不是直接发？</p><p>因为requester只和它的direct peers有TCP connection，和目标节点可能没有connection</p><p>但是会带来更高的延迟</p></li><li><p><code>QueryHit</code> 之后使用HTTP传输文件。</p></li><li><p><strong>Not scalable</strong> (因为find peer / find content所需的工作量指数级增长)</p></li><li><p><strong>Limited scope query flooding</strong>: 在query message中添加 <code>peer-count</code> 属性，每经过一个hop减小1，从而限制hop的次数。</p></li><li><p>但是仍然会有peer数量太多的问题，并且不能保证一定能找到目标 (<strong>no guarantee</strong>)</p></li></ul><img src="/2025/056_cmu_14740/locate-content.png" srcset="/img/loading.gif" lazyload></li></ul><h2 id="kazaa-hybridhierarchical-p2p"><a class="markdownIt-Anchor" href="#kazaa-hybridhierarchical-p2p"></a> KaZaA (Hybrid/Hierarchical P2P)</h2><p>KaZaA使用 <strong>Hierarchical (Hybrid) Design</strong></p><p>每个节点是 Super Node (SN) 或 Ordinary Node (ON)</p><ul><li>SN是leader，ON和SN有TCP连接，部分SN和SN之间有TCP连接</li><li>SN存储了children的信息</li><li>某一个ON要找文件时，会询问它的parent (SN) 有没有，如果SN和SN的children都找不到所需信息，会问别的SN (SN-to-SN connections)</li><li>优点: 与Gnutella相比能够支持明显更多的peers，且没有<strong>scalability</strong>问题</li><li><strong>KaZaA query</strong>: client发送query，SN返回 <strong>meta data, hash, IP address (of the peer)</strong></li><li>KaZaA实现细节不公开，有人做Reverse engineering</li><li>ON-SN, SN-SN的连接很短，因为node会不断寻找其余workload更小的节点</li></ul><h1 id="lec-8-transport-layer-udp"><a class="markdownIt-Anchor" href="#lec-8-transport-layer-udp"></a> Lec 8. Transport Layer UDP</h1><h2 id="transport-layer"><a class="markdownIt-Anchor" href="#transport-layer"></a> Transport Layer</h2><p><strong>Mission</strong>: Offers <strong>Peer-to-peer</strong> and <strong>end-to-end</strong> (virtual or logical) connections between two <strong>processes (applications)</strong> running on remote hosts.</p><p>Network Layer provides Internet Protocol (IP)</p><ul><li><p>IP - <strong>packet switching</strong> 不提供reliability</p><p>(第一节课内容：circuit switching: connection-oriented, FDM/TDM; packet switching: connectionless)</p></li></ul><p>Transport Layer protocols 主要有TCP和UDP</p><p>Transport Layer 主要功能</p><ul><li><p><strong>Multiplex</strong> &amp; <strong>De-multiplex</strong>: process的信息在发送方TL multiplex，接收方TL de-multiplex</p><ul><li>有multiplex一定需要addressing, Transport Layer用<strong>port numbers</strong>来addressing</li><li>Port Assignment: 端口一共有三种类型：<strong>well-known</strong> (0-1023), <strong>registered</strong> (1024-49151), <strong>dynamic or ephemeral</strong> (49152-65535)</li><li>Port numbers are bound to an application</li></ul></li><li><p><strong>Breaking data into segments</strong> and reassemble at receiver</p><ul><li><p>发送方的Application Layer提供任意长度的信息，Transport Layer会将其切成<strong>segments</strong>，一个一个发送</p><ul><li><p>TL会往每个segments前添加header</p></li><li><p>后续会被封装成<strong>packets</strong>(aka <strong>datagrams</strong>)，然后封装成<strong>frames</strong></p><img src="/2025/056_cmu_14740/encapsulation-layers.png" srcset="/img/loading.gif" lazyload></li></ul></li><li><p>接收方的Transport Layer接收到segments，重新组装，传给Application layer</p></li></ul></li><li><p>connection setup, state management, connection teardown (if necessary)</p></li><li><p>TCP: reliability guarantees.</p></li></ul><h2 id="udp"><a class="markdownIt-Anchor" href="#udp"></a> UDP</h2><p>缺点：segments可能丢失，可能顺序乱</p><p>优点：</p><ul><li><strong>connectionless</strong> (不需要handshake/agreement，不需要预先建立连接)</li><li><strong>simple</strong>: no state to maintain</li><li>UDP header is smaller</li><li>No congestion or flow control (less processing overhead)</li><li>reliability可以在Application Layer添加，开销更低</li></ul><p>UDP常用于</p><ul><li>loss tolerant &amp; rate sensitive (timeliness): 多媒体应用，例如直播</li><li>big overhead compared to transmitted data: payload很小的应用，例如DNS</li></ul><p><strong>UDP segment format</strong>:</p><p>UDP的<strong>header</strong>一共<strong>8bytes/64bits</strong></p><p><strong>source port, destination port, length, checksum</strong>各占16bits</p><p>Notes:</p><ul><li>length是整个segment包含header的长度，单位为bytes</li><li>为什么需要包含source port number？因为另一边回复时需要用到（需要反转source port#和dest port#）</li><li><strong>checksum</strong>: end-to-end detection<ul><li>发送方：把segments中的所有16-bit words加起来，如果加法过程中产生进位1，则给结果加上进位1。最后反转所有bit。</li><li>接收方：把所有segment连带着checksum一起加起来，同样如果产生进位则加上进位。结果必须全1.</li><li>如果UDP发现有错误，则会丢弃，如果没错误则上传给application layer</li></ul></li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Lecture-Notes/" class="category-chain-item">Lecture Notes</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Lecture-Notes/" class="print-no-link">#Lecture Notes</a></div></div><div class="license-box my-3"><div class="license-title"><div>[Lecture Notes] CMU 14-740 Fundamentals of Telecommunication Networks</div><div>https://www.billhu.us/2025/056_cmu_14740/</div></div><div class="license-meta"><div class="license-meta-item"><div>Author</div><div>Bill Hu</div></div><div class="license-meta-item license-meta-date"><div>Posted on</div><div>January 16, 2025</div></div><div class="license-meta-item"><div>Licensed under</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - Attribution"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"></article><article class="post-next col-6"><a href="/2025/057_cmu_17514/" title="[Lecture Notes] CMU 17-514 Software Construction"><span class="hidden-mobile">[Lecture Notes] CMU 17-514 Software Construction</span> <span class="visible-mobile">Next</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>Table of Contents</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">Search</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">Keyword</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <span>With </span><a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <i class="iconfont icon-love"></i> <a href="/about" target="_blank" rel="nofollow noopener"><span>Bill Hu</span></a><div style="font-size:.85rem"><span id="timeDate">Loading days...</span> <span id="times">Loading time...</span><script src="/js/duration.min.js"></script></div></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,t=t.getElementById("subtitle");t&&e&&e(t.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){var t;"tocbot"in window&&(tocbot.refresh(),0!==(t=jQuery("#toc")).length)&&tocbot&&0<t.find(".toc-list-item").length&&t.css("visibility","visible")}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback(function(){if("anchors"in window){anchors.removeAll();var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}})})</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">Blog works best with JavaScript enabled</div></noscript></body></html>