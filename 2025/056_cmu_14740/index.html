<!DOCTYPE html><html lang="en" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Bill Hu"><meta name="keywords" content=""><meta name="description" content="CMU 14-740 Notes: Fundamentals of Telecommunication Networks"><meta property="og:type" content="article"><meta property="og:title" content="[Lecture Notes] CMU 14-740 Fundamentals of Telecommunication Networks"><meta property="og:url" content="https://www.billhu.us/2025/056_cmu_14740/index.html"><meta property="og:site_name" content="Bill Hu&#39;s Blog"><meta property="og:description" content="CMU 14-740 Notes: Fundamentals of Telecommunication Networks"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/tcp-layers.webp"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/encapsulation.webp"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/ip-hourglass-design.webp"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/peer-transit.webp"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/non-persistent-http.webp"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/persistent-http-pipelining.webp"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/server-push.webp"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/dns-query-navigation.webp"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/zone-nameserver.webp"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/dns-hierarchy.webp"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/bootstraping-in-gnutella.webp"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/locate-content.webp"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/encapsulation-layers.webp"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/swv2.webp"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/swv3.webp"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/GBN.webp"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/sr-window.webp"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/tcp-segment.webp"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/tcp-close-connection.webp"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/tcp-tahoe-vs-reno.png"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/quic-0-rtt.png"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/IP-header.png"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/routing-protocols.png"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/ospf-hierarchy.png"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/SNMP-arch.png"><meta property="og:image" content="https://www.billhu.us/2025/056_cmu_14740/snmp-traffic-matrix.png"><meta property="article:published_time" content="2025-01-16T19:17:06.000Z"><meta property="article:modified_time" content="2025-11-27T23:12:13.459Z"><meta property="article:author" content="Bill Hu"><meta property="article:tag" content="Lecture Notes"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://www.billhu.us/2025/056_cmu_14740/tcp-layers.webp"><title>[Lecture Notes] CMU 14-740 Fundamentals of Telecommunication Networks - Bill Hu&#39;s Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.15.6/katex.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/myfont.css"><link rel="stylesheet" href="/css/jetbrains-mono.css"><script id="fluid-configs">var dntVal,Fluid=window.Fluid||{},CONFIG=(Fluid.ctx=Object.assign({},Fluid.ctx),{hostname:"www.billhu.us",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:25,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:3},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},gtag:null},search_path:"/local-search.xml",include_content_in_search:!0});CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script>!function(t,e,n,c,a,r){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(a=e.createElement(c)).async=1,a.src="https://www.clarity.ms/tag/fjnxcr4gva",(r=e.getElementsByTagName(c)[0]).parentNode.insertBefore(a,r)}(window,document,"clarity","script")</script><meta name="google-site-verification" content="IqNfw3GiMxuhw7kYoEdhMJoh3j99KHuGI9bw00hPn2c"><link href="https://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Kaushan+Script" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic,700italic" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto+Slab:400,100,300,700" rel="stylesheet"><meta name="generator" content="Hexo 7.2.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Bill Hu&#39;s Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>Home</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>Archives</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>Categories</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>Tags</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>About</span></a></li><li class="nav-item"><a class="nav-link" href="https://www.billhu.xyz" target="_self"><i class="iconfont icon-code"></i> <span>Portfolio</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="[Lecture Notes] CMU 14-740 Fundamentals of Telecommunication Networks"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2025-01-16 19:17" pubdate>January 16, 2025 pm</time></span></div><div class="mt-1"></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">[Lecture Notes] CMU 14-740 Fundamentals of Telecommunication Networks</h1><div class="markdown-body"><h1 id="lec-1-intro"><a class="markdownIt-Anchor" href="#lec-1-intro"></a> Lec 1. Intro</h1><p>Network <strong>Protocols</strong>: Define the <strong>format</strong> (of a message), <strong>order</strong> of messages sent and received among network entities, and <strong>actions</strong> taken on message transmission or receipt.</p><p>所有Internet的通信活动都由protocol管。</p><p>Reliable: 发送到的和接收到的数据一致，顺序一致。要reliable就会有overhead，需要trade-off.</p><ul><li><strong>circuit switching</strong><ul><li>每一个connection都有一个channel, <strong>connection-oriented</strong></li><li>在没有connection/call/user使用的时候会导致资源浪费</li><li>每一个信号都有time和frequency，同一时刻有不同频率的信号频段都可以传输。如何切分？<ul><li><strong>FDM</strong> (Frequency Division Multiplexing) 频分复用</li><li><strong>TDM</strong> (Time Division Multiplexing) 时分复用</li></ul></li></ul></li><li><strong>packet switching</strong><ul><li><strong>Connectionless</strong>, 没有channel，用多个paths</li><li>数据切分成小块，称为packets</li><li>所有用户都可以使用完整的带宽，没有FDM、TDM等，<strong>statistical sharing</strong></li><li><strong>Store and forward model</strong>: 一条link上有好多个节点，节点必须接收到完整packet才会继续发送给下一个节点</li><li>缺点是会有congestion，数据包太多会导致竞争</li></ul></li></ul><h1 id="lec-2-architecture"><a class="markdownIt-Anchor" href="#lec-2-architecture"></a> Lec 2. Architecture</h1><p>packet switching: 每一个packet都能占用全部的bandwidth，需要<strong>queue</strong></p><p>如果queue满了，新的packet会被<strong>drop</strong>（aka lost, 丢包）</p><hr><p>4 Sources of packet delay</p><ul><li><strong>processing delay</strong> (nodal processing)<ul><li>Router接收到packet时需要：①检查bit errors ②决定转发给谁</li><li>与router的处理速度有关</li></ul></li><li><strong>queueing delay</strong><ul><li>router一次只能发一个packet，需要排队等待</li><li>与router的congestion level （拥堵情况）、buffer size都有关</li><li>范围可以从0到无穷（无穷代表丢包）</li><li>Traffic intensity <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi><mo>=</mo><mi>L</mi><mo>×</mo><mi>λ</mi><mi mathvariant="normal">/</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">\rho = L \times \lambda / R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">ρ</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.76666em;vertical-align:-.08333em"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">λ</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:.00773em">R</span></span></span></span> (=输入除以输出)<ul><li>L = Packet Length (bits/pkt)</li><li>R = Link Speed / Data Rate (bps)</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">λ</span></span></span></span> = Average Packet Arrival Rate (pkt/s)</li></ul></li></ul></li><li><strong>transmission delay</strong><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">T_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.2805559999999999em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi mathvariant="normal">/</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">L/R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">L</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:.00773em">R</span></span></span></span> = Packet Length / Link Bandwidth</li></ul></li><li><strong>propagation delay</strong><ul><li>第一个bit发送需要的延迟时间。取决于光速（或物理介质速度）</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>p</mi></msub><mo>=</mo><mi>d</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">T_p = d / s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.969438em;vertical-align:-.286108em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.15139200000000003em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">d</span><span class="mord">/</span><span class="mord mathnormal">s</span></span></span></span> = Length of physical link / Propagation speed in physical medium</li></ul></li></ul><p>Traceroute：发送给第i个node来回的时间</p><hr><p>Layered Network Architecture</p><ul><li><p>Layer的优点</p><ul><li>每个layer里面的protocol可以分开设计，互不干扰，简化设计、实现和测试流程</li></ul></li><li><p>Layer的缺点</p><ul><li>duplication：每个layer都做了一些reliability的设计，导致重复</li><li>每层layer之间隐藏了信息，可能影响性能（完成某些操作可能需要底层layer的信息）</li></ul></li><li><p><strong>ISO OSI</strong> reference model / <strong>TCP/IP</strong></p><ul><li><p>1970s的时候不同的网络架构互不兼容，无法互相通信，所以ISO搞出了OSI来实现 <strong>interoperability</strong></p></li><li><p>ISO: International Standard Organization</p></li><li><p>OSI: Open Systems Interconnection</p></li><li><p>然后 TCP/IP 把OSI protocol给取代了</p></li><li><p>OSI有7层layer，TCP/IP有5层layer。顶上两个是end-to-end，底下的是hop-by-hop.</p><img src="/2025/056_cmu_14740/tcp-layers.webp" srcset="/img/loading.gif" lazyload></li></ul></li></ul><h1 id="lec-3-design-principles"><a class="markdownIt-Anchor" href="#lec-3-design-principles"></a> Lec 3. Design Principles</h1><h2 id="virtual-connections"><a class="markdownIt-Anchor" href="#virtual-connections"></a> Virtual connections</h2><p>每层layer都有自己的header。</p><p><strong>Encapsulation</strong>: Sending host, 从更高层layer获取信息，在payload前加一个自己的header</p><p><strong>Decapsulation</strong>: Receiving host, 从更底层layer获取信息，从自己的header提取信息然后去掉</p><img src="/2025/056_cmu_14740/encapsulation.webp" srcset="/img/loading.gif" lazyload><h2 id="tcpip"><a class="markdownIt-Anchor" href="#tcpip"></a> TCP/IP</h2><img src="/2025/056_cmu_14740/ip-hourglass-design.webp" srcset="/img/loading.gif" lazyload><ul><li><p>“<strong>Hourglass</strong>” design, IP 是最中间的glue，IP的上层和下层都有很多东西</p><p>缺点：IP至关重要，并且改IP很困难，像IPv4到IPv6的迁移非常复杂。</p></li><li><p><strong>No Strict layering</strong>: 应用程序也可以绕过layer直接用底层。</p></li><li><p>协议需要 <strong>standardized</strong>.</p><ul><li>Internet Engineering Task Force (IETF). 每个IETF标准都公开发布了Request for Comments (RFC).</li><li>但不是所有RFC都成为了标准。RFC包含实验性的协议</li></ul></li></ul><h2 id="goals-of-tcpip-design"><a class="markdownIt-Anchor" href="#goals-of-tcpip-design"></a> Goals of TCP/IP design</h2><p>Clark88论文</p><ul><li><strong>Fundamental goal</strong>: 把现有的网络给interconnect起来。使用 store-and-forward packet-switching 方法，用 gateways 连接起来.</li><li><strong>Second level goals</strong>:<ul><li>continue despite failures 失败了也要继续（失败了要重建连接）<ul><li>需要保存state(状态信息)，这样连接中断了才能重新建立连接</li><li>state是存在intermediate nodes还是存在end-hosts? 存在end-hosts里。<strong>stateless nodes</strong>.</li></ul></li><li>支持多种服务<ul><li>TCP: <strong>Connection-oriented</strong>; UDP: <strong>connectionless</strong></li><li>最初TCP的目标是connection-oriented and reliable。Reliability是主要的延迟来源。所以TCP和IP分离了，搞了个UDP。</li></ul></li><li>支持多种网络技术（有线网、无线电等）</li><li>distributed management 自己需要能管理自己的网络<ul><li>networks can be administered separately</li></ul></li><li>cost-effective 效率</li><li>account for resources used<ul><li>早期设计的时候没有人在意（现在很多人在意网速）。</li></ul></li><li>上述后两个目标并没有获得太多attention甚至完全没有被考虑过</li></ul></li></ul><h1 id="lec-4-internet-isps-architecture"><a class="markdownIt-Anchor" href="#lec-4-internet-isps-architecture"></a> Lec 4. Internet ISP’s Architecture</h1><p>The Internet is a <strong>Network of Networks</strong>.</p><p>ISP: <strong>Internet Service Provider</strong></p><p>A <strong>backbone</strong> network ISP: 能够让所有customers连接到全球网络</p><ul><li>最早的时候只有一个backbone ISP叫做 <code>NSFNET</code></li><li>但是这样做不好，比如有两个中国电脑通信，仍然需要经过位于美国的全球唯一backbone</li><li>所以出现了多个 commercial backbone ISP 互相interconnect来实现全球互联网连接</li></ul><h2 id="transit-peering"><a class="markdownIt-Anchor" href="#transit-peering"></a> Transit &amp; Peering</h2><p><strong>Transit</strong> interface: 一个backbone ISP将网络传输服务售卖给客户（“客户”指更小的ISP或别的大企业）</p><p><strong>Peering</strong> interface: ISP之间互相直接访问</p><ul><li>peering通常是免费的，互惠互利，数据直接传输，不经过transit provider</li><li>peering的关系通常是商业机密</li></ul><h2 id="different-types-of-isp"><a class="markdownIt-Anchor" href="#different-types-of-isp"></a> Different types of ISP</h2><p><strong>Tier-1</strong>：</p><ul><li>Tier-1的定义已经被滥用，每个ISP都自称自己是Tier-1。通常Tier-1指的是：<ul><li>① 和一大堆customer有 <strong>transit</strong> link</li><li>② 和一大堆别的Tier-1 backbone ISP有 <strong>peering</strong> (business) interconnections. (通常有 <strong>full-mesh</strong> architecture)</li></ul></li><li>Tier-1网速快，延迟低，全球都有，与很多Tier-2 ISP相连（Tier-2 ISP是Tier-1 ISP的transit customers)</li><li>Tier-1不需要从别的ISP购买transit就可以访问到全球互联网</li><li>Tier-1 ISP通常有一种 <strong>restrictive peering policy</strong><ul><li>不要轻易跟别的非Tier-1 ISP去peer，因为它们是潜在的客户，要向它们收钱</li></ul></li></ul><p><strong>Tier-2</strong>:</p><ul><li>通常来说，不是 Tier-1 的ISP就叫做 Tier-2.</li><li>Tier-2需要从Tier-1 ISP购买transit access</li><li>Tier-2向更下层的客户提供付费transit服务</li><li>Tier-2和Tier-2之间也会peer。通常有一种 <strong>open-peering policy</strong><ul><li>Tier-2要和尽可能多的ISP去peer</li><li>需要权衡一下成本：Peer会产生 <strong>management cost</strong> 和 <strong>maintenance cost</strong></li></ul></li></ul><img src="/2025/056_cmu_14740/peer-transit.webp" srcset="/img/loading.gif" lazyload><p>这几年有个新东西进入了ISP体系结构：<strong>Content Providers</strong> (Large Enterprise Companies)</p><p><strong>Content Providers</strong></p><ul><li>Do not sell transit.</li><li>可分为以下两类<ul><li>Category A: Focus on content creation<ul><li>不peering，不运作网络</li></ul></li><li>Category B: Sophisticated, large-scale players<ul><li>open peering policy</li></ul></li></ul></li></ul><h1 id="lec-5-application-layer-http"><a class="markdownIt-Anchor" href="#lec-5-application-layer-http"></a> Lec 5. Application Layer &amp; HTTP</h1><p>Application Layer <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">≠</mo></mrow><annotation encoding="application/x-tex">\neq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span></span></span></span> User Application</p><p>Application Layer provides Services (e.g. SMTP, HTTP, FTP, SSH)</p><p>许多Application Layer Services需要先创建一个<strong>Transport Layer</strong> (TL) <strong>connection</strong> (channel).</p><h2 id="http"><a class="markdownIt-Anchor" href="#http"></a> HTTP</h2><p><strong>HTTP-message</strong> 由 <strong>request</strong> 或 <strong>response</strong> 组成</p><p>Request或Response由 <strong>start line</strong>, <strong>header</strong>, <strong>empty line</strong> 和 <strong>message body</strong> 组成</p><ul><li><p><strong>Start line</strong>: <code>Request-line</code> 或 <code>Status-line</code></p><ul><li><p><code>Request-line</code> = <code>Method</code> sp <code>Request-URI</code> sp <code>HTTP-Version</code> CRLF</p><p>e.g. <code>GET /images/logos.html HTTP/1.1</code></p><p>Method包含 <code>GET</code>, <code>POST</code>, <code>HEAD</code>, <code>PUT</code>, <code>DELETE</code></p><p>Method中的<code>GET</code>:</p><ul><li><strong>conditional <code>GET</code></strong>: <code>If-Modified-Since</code>, <code>If-Match</code></li><li><strong>partial <code>GET</code></strong>: 只获取一个object的指定byte范围。header中包含<code>RANGE</code> field。</li></ul><p>Method中的 <code>HEAD</code>: 获取metadata（与GET相同，但不包含message body）</p><p>Method中的 <code>OPTIONS</code>: 获取服务器或资源的能力，不获取资源本身</p></li><li><p><code>Status-line</code> = <code>HTTP-version</code> sp <code>Status-Code</code> sp <code>Reason-Phrase</code> CRLF</p><p>e.g. <code>HTTP/1.1 200 OK\r\n Connection: close...</code></p><p>Status code 是三位数字：</p><ul><li><code>1xx</code>: informational: 请求已收到，正在处理</li><li><code>2xx</code>: success 成功</li><li><code>3xx</code>: redirection 重定向/完成请求需要更多操作</li><li><code>4xx</code>: client error 因为client的错误导致请求格式错误或无法满足请求</li><li><code>5xx</code>: server error 请求完全正确，但服务器原因导致无法满足请求 (e.g. <code>505 HTTP Version Not Supported</code>)</li></ul></li></ul></li><li><p>0个或多个<strong>headers</strong> (<strong>General, Request, or Entity headers</strong>)</p><ul><li>e.g. <code>User-agent: mozilla/5.0... \r\n Connection: close</code></li><li>Header包含HTTP request/response的 <strong>metadata</strong><ul><li>日期，时间，Application或服务器信息，缓存控制，46个有定义的header</li></ul></li><li>HTTP Request 需要 <code>HOST</code> 这一项（Response不需要）</li></ul></li><li><p>空行 (CRLF)</p><p>空行是为了把header和body区分开</p></li><li><p>message body (optional)</p></li></ul><h2 id="persistent-non-persistent-connections"><a class="markdownIt-Anchor" href="#persistent-non-persistent-connections"></a> Persistent &amp; Non-persistent Connections</h2><p>HTTP用TCP作为Transport Layer Protocol</p><p>(TCP在Transport层，HTTP在Application层)</p><p>建立一个HTTP连接需要先建立TCP连接</p><p><strong>Round Trip Time (RTT)</strong>: 发送一条消息并得到回复的所需时间</p><ul><li><p><strong>Non-persistent HTTP</strong></p><p>需要1个RTT建立TCP连接，1个RTT建立HTTP连接，然后传数据，最后1个RTT关闭连接</p><p>Total Transmission Time = 2RTT + file transmit time</p><p>Total Time (包括关闭连接) = 3RTT + file transmit time</p><img src="/2025/056_cmu_14740/non-persistent-http.webp" srcset="/img/loading.gif" lazyload></li><li><p><strong>Persistent HTTP</strong></p><ul><li><p>① <strong>Reuse existing TCP connection</strong></p><p>传数据之后不要关闭TCP connection，省去下一次建立TCP连接的时间</p></li><li><p>② <strong>Pipelining</strong> at the Application Layer level</p><p>不等到上一个(HTTP)请求收到回复，就发送下一个request。服务器按照顺序发送数据包。这样所有object最少只需要占用1个RTT</p><p>HTTP/1.1默认使用这样的 Persistent HTTP + Pipelining</p><img src="/2025/056_cmu_14740/persistent-http-pipelining.webp" srcset="/img/loading.gif" lazyload></li><li><p><strong>Server Push</strong> in HTTP 2.0</p><p>服务器提前把client会用到的objects主动发过来，不需要client去请求</p><img src="/2025/056_cmu_14740/server-push.webp" srcset="/img/loading.gif" lazyload></li></ul></li></ul><h2 id="caching"><a class="markdownIt-Anchor" href="#caching"></a> Caching</h2><ul><li><p><strong>Web Proxy Caching</strong></p><p>建立一个中转代理 <strong>Local Cache</strong> (aka <strong>Local Web Proxy</strong>)</p></li><li><p><strong>File Validation</strong> in HTTP Caching</p><p>HTTP会想办法确保cache是否valid（cache的文件有没有过期）</p><p>有两种 <strong>Cache Expiration Model</strong></p><ul><li><p><strong>Origin Server-specified expiration</strong></p><p>服务器使用 <code>Expires</code> 或 <code>max-age</code> header 直接告诉文件多久后过期</p></li><li><p><strong>Heuristic expiration</strong></p><p>服务器不给定过期时间，client请求资源时用 <code>If-modified-since</code> header，问服务器“我手里的资源是否fresh有没有过期？”</p><p>如果资源过期则发送，资源没过期则用 304 Not Modified 避免重新传输。</p></li></ul></li></ul><h1 id="lec-6-dns"><a class="markdownIt-Anchor" href="#lec-6-dns"></a> Lec 6. DNS</h1><h2 id="dns-services-dns作用"><a class="markdownIt-Anchor" href="#dns-services-dns作用"></a> DNS services (DNS作用)</h2><ul><li><strong>Domain</strong> 与 <strong>IP address</strong> 的转换</li><li><strong>Host aliasing</strong> (alias 和 canonical domain names 的转换)</li><li><strong>Mail Server aliasing</strong> (MX - Mail Exchange)</li><li><strong>Load distribution across Name Servers</strong> (一个域名轮换指向多个服务器)</li></ul><h2 id="dns-protocol"><a class="markdownIt-Anchor" href="#dns-protocol"></a> DNS Protocol</h2><p><strong>Query</strong> and <strong>Reply</strong> (和HTTP类似)</p><ul><li>query和reply用同样的消息格式：<strong>Resource Record (RR)</strong></li><li>每个**Resource Record (RR)**由五部分组成：<code>(Name, Value, Type, Class, TTL)</code></li><li><code>Name</code>: 由RR中的<code>Type</code>决定</li><li><code>Value</code>: e.g. 对于A解析，value是IP地址；对于CNAME解析，value是另一个域名</li><li><code>Type</code>: e.g. <code>A</code>, <code>CNAME</code> 等<ul><li><code>A</code>: Address 指向IPv4地址，<code>AAAA</code> 指向IPv6地址</li><li><code>NS</code>: Nameserver: 指向Authoritative (organization) Name Server，例如cmu有自己的DNS，<a target="_blank" rel="noopener" href="http://Name=cmu.edu">Name=cmu.edu</a>, <a target="_blank" rel="noopener" href="http://Value=dns.cmu.edu">Value=dns.cmu.edu</a></li><li><code>CNAME</code>: Canonical Name</li><li><code>MX</code>: Mail Exchange 指向邮件服务器的hostname</li></ul></li><li><code>Class</code>: 通常全都是 <code>IN</code> 意为Internet</li><li><code>TTL</code>: Time to live 代表这一条RR能被缓存多久，0代表不能缓存</li></ul><p>DNS queries 在<strong>53</strong>号端口上用<strong>UDP</strong>运行</p><ul><li>Exception：在①Zone transfer②大于512字节的response 时会使用TCP</li><li>为什么用UDP？因为TCP的overhead通常比整个DNS query都要大</li></ul><h2 id="navigation"><a class="markdownIt-Anchor" href="#navigation"></a> <strong>Navigation</strong></h2><p>Client可能需要问多个Name Servers (NS)</p><p>每个Name Server返回指向下一个NS的指针（不止返回NS record，也另外返回一个指向另一个NS的A record）</p><ul><li><strong>Non-recursive</strong> (右上图片) 有时也叫 <strong>Iterative</strong></li><li><strong>Recursive</strong> (右下图片)</li></ul><img src="/2025/056_cmu_14740/dns-query-navigation.webp" srcset="/img/loading.gif" lazyload><p><strong>DNS caching</strong></p><ul><li>Name Server (NS) 会缓存DNS mapping</li><li>由TTL决定cache多久</li><li>Local Name Servers (Resolves) 通常缓存Top Level Domain (TLD) servers的IP地址</li></ul><h2 id="dns-name-server-hierarchy"><a class="markdownIt-Anchor" href="#dns-name-server-hierarchy"></a> <strong>DNS Name Server Hierarchy</strong></h2><ul><li><p>1 <strong>Root</strong> (root name servers)</p></li><li><p>2 <strong>Top-Level Domain (TLD</strong> Name servers)</p></li><li><p>3 <strong>Authoritative</strong> (e.g. cmu name servers)</p></li><li><p><strong>delegated administrative structure</strong>:</p><ul><li><p>delegated指域名是反着来的 e.g. <a target="_blank" rel="noopener" href="http://library.cmu.edu">library.cmu.edu</a></p></li><li><p>administrative authority 不一定和 <strong>namespace hierarchy</strong>相符</p><p>e.g. cs.cmu.edu有自己的name server, drama.cmu.edu没有</p></li></ul></li><li><p><strong>Zones</strong></p><ul><li><p>namespace hierarchy被分成一个一个zones</p></li><li><p>每一个zone有一个name server</p></li><li><p>zone owner必须：maintain zone data; run redundant name servers (for backup)</p><img src="/2025/056_cmu_14740/zone-nameserver.webp" srcset="/img/loading.gif" lazyload></li><li><p><strong>Root Name Server</strong> 知道所有TLD nameserver和它们的地址</p><ul><li>一共只有13个root server，标记为a到m</li></ul></li><li><p><strong>TLD</strong> （e.g. .com, .org, .net）</p><ul><li>由 IANA (Internet Assigned Number Authority) 管理</li><li>TLD NS知道它自己所有域名的所有authoritative (or intermediate) name server的地址</li></ul></li><li><p><strong>Authoritative NS</strong></p></li><li><p><strong>Local Name Server</strong> (DNS Resolver) 也叫 <strong>Default Name Server or Resolver</strong></p><ul><li>并不严格属于DNS结构</li><li>每个organization（公司、学校等）都有一个</li><li>Act as a proxy</li></ul></li></ul></li></ul><img src="/2025/056_cmu_14740/dns-hierarchy.webp" srcset="/img/loading.gif" lazyload><h1 id="lec-7-p2p"><a class="markdownIt-Anchor" href="#lec-7-p2p"></a> Lec 7. P2P</h1><p>P2P: Peer-to-peer</p><h2 id="napster-centralized-p2p"><a class="markdownIt-Anchor" href="#napster-centralized-p2p"></a> Napster (Centralized P2P)</h2><p>Napster曾经是第一个p2p music-sharing应用</p><ul><li><p><strong>Centralized</strong>: clients存储文件, 中央server只存储peer信息: <code>&lt;file name, ip address, port number&gt;</code></p></li><li><p>虽然传文件是decentralized，但是定位文件是highly centralized</p></li><li><p>==&gt; 导致的问题: 中央服务器稳定性、中央服务器性能瓶颈</p></li></ul><h2 id="gnutella-distributed-p2p"><a class="markdownIt-Anchor" href="#gnutella-distributed-p2p"></a> Gnutella (Distributed P2P)</h2><ul><li><p>Fully <strong>decentralized (distributed)</strong></p><p>不需要中心的服务器，用户们自己安排自己</p></li><li><p><strong>Not scalable</strong></p><ul><li>fully distributed <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">≠</mo></mrow><annotation encoding="application/x-tex">\neq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span></span></span></span> scalable</li></ul></li><li><p><strong>Bootstraping</strong></p><p>Find peers的方法：每个节点<strong>relay</strong> <strong>ping/pong</strong> messages</p><p>这样每个节点都能得到所有bootstrap nodes的列表</p><img src="/2025/056_cmu_14740/bootstraping-in-gnutella.webp" srcset="/img/loading.gif" lazyload></li><li><p>Locate content: <strong>query flooding</strong></p><ul><li><p>节点从现有的TCP连接发出<code>Query</code>消息，相连的Node会relay</p></li><li><p><code>QueryHit</code> 消息会沿着反向路径发出</p></li><li><p>为什么reverse path发送而不是直接发？</p><p>因为requester只和它的direct peers有TCP connection，和目标节点可能没有connection</p><p>但是会带来更高的延迟</p></li><li><p><code>QueryHit</code> 之后使用HTTP传输文件。</p></li><li><p><strong>Not scalable</strong> (因为find peer / find content所需的工作量指数级增长)</p></li><li><p><strong>Limited scope query flooding</strong>: 在query message中添加 <code>peer-count</code> 属性，每经过一个hop减小1，从而限制hop的次数。</p></li><li><p>但是仍然会有peer数量太多的问题，并且不能保证一定能找到目标 (<strong>no guarantee</strong>)</p></li></ul><img src="/2025/056_cmu_14740/locate-content.webp" srcset="/img/loading.gif" lazyload></li></ul><h2 id="kazaa-hybridhierarchical-p2p"><a class="markdownIt-Anchor" href="#kazaa-hybridhierarchical-p2p"></a> KaZaA (Hybrid/Hierarchical P2P)</h2><p>KaZaA使用 <strong>Hierarchical (Hybrid) Design</strong></p><p>每个节点是 Super Node (SN) 或 Ordinary Node (ON)</p><ul><li>SN是leader，ON和SN有TCP连接，部分SN和SN之间有TCP连接</li><li>SN存储了children的信息</li><li>某一个ON要找文件时，会询问它的parent (SN) 有没有，如果SN和SN的children都找不到所需信息，会问别的SN (SN-to-SN connections)</li><li>优点: 与Gnutella相比能够支持明显更多的peers，且没有<strong>scalability</strong>问题</li><li><strong>KaZaA query</strong>: client发送query，SN返回 <strong>meta data, hash, IP address (of the peer)</strong></li><li>KaZaA实现细节不公开，有人做Reverse engineering</li><li>ON-SN, SN-SN的连接很短，因为node会不断寻找其余workload更小的节点</li></ul><h1 id="lec-8-transport-layer-udp"><a class="markdownIt-Anchor" href="#lec-8-transport-layer-udp"></a> Lec 8. Transport Layer UDP</h1><h2 id="transport-layer"><a class="markdownIt-Anchor" href="#transport-layer"></a> Transport Layer</h2><p><strong>Mission</strong>: Offers <strong>Peer-to-peer</strong> and <strong>end-to-end</strong> (virtual or logical) connections between two <strong>processes (applications)</strong> running on remote hosts.</p><p>Network Layer provides Internet Protocol (IP)</p><ul><li><p>IP - <strong>packet switching</strong> 不提供reliability</p><p>(第一节课内容：circuit switching: connection-oriented, FDM/TDM; packet switching: connectionless)</p></li></ul><p>Transport Layer protocols 主要有TCP和UDP</p><p>Transport Layer 主要功能</p><ul><li><p><strong>Multiplex</strong> &amp; <strong>De-multiplex</strong>: process的信息在发送方TL multiplex，接收方TL de-multiplex</p><ul><li>有multiplex一定需要addressing, Transport Layer用<strong>port numbers</strong>来addressing</li><li>Port Assignment: 端口一共有三种类型：<strong>well-known</strong> (0-1023), <strong>registered</strong> (1024-49151), <strong>dynamic or ephemeral</strong> (49152-65535)</li><li>Port numbers are bound to an application</li></ul></li><li><p><strong>Breaking data into segments</strong> and reassemble at receiver</p><ul><li><p>发送方的Application Layer提供任意长度的信息，Transport Layer会将其切成<strong>segments</strong>，一个一个发送</p><ul><li><p>TL会往每个segments前添加header</p></li><li><p>后续会被封装成<strong>packets</strong>(aka <strong>datagrams</strong>)，然后封装成<strong>frames</strong></p><img src="/2025/056_cmu_14740/encapsulation-layers.webp" srcset="/img/loading.gif" lazyload></li></ul></li><li><p>接收方的Transport Layer接收到segments，重新组装，传给Application layer</p></li></ul></li><li><p>connection setup, state management, connection teardown (if necessary)</p></li><li><p>TCP: reliability guarantees.</p></li></ul><h2 id="udp"><a class="markdownIt-Anchor" href="#udp"></a> UDP</h2><p>缺点：segments可能丢失，可能顺序乱</p><p>优点：</p><ul><li><strong>connectionless</strong> (不需要handshake/agreement，不需要预先建立连接)</li><li><strong>simple</strong>: no state to maintain</li><li>UDP header is smaller</li><li>No congestion or flow control (less processing overhead)</li><li>reliability可以在Application Layer添加，开销更低</li></ul><p>UDP常用于</p><ul><li>loss tolerant &amp; rate sensitive (timeliness): 多媒体应用，例如直播</li><li>big overhead compared to transmitted data: payload很小的应用，例如DNS</li></ul><p><strong>UDP segment format</strong>:</p><p>UDP的<strong>header</strong>一共<strong>8bytes/64bits</strong></p><p><strong>source port, destination port, length, checksum</strong>各占16bits</p><p>Notes:</p><ul><li>length是整个segment包含header的长度，单位为bytes</li><li>为什么需要包含source port number？因为另一边回复时需要用到（需要反转source port#和dest port#）</li><li><strong>checksum</strong>: end-to-end detection<ul><li>发送方：把segments中的所有16-bit words加起来，如果加法过程中产生进位1，则给结果加上进位1。最后反转所有bit。</li><li>接收方：把所有segment连带着checksum一起加起来，同样如果产生进位则加上进位。结果必须全1.</li><li>如果UDP发现有错误，则会丢弃，如果没错误则上传给application layer</li></ul></li></ul><h1 id="quiz-1"><a class="markdownIt-Anchor" href="#quiz-1"></a> Quiz 1</h1><p>Quiz1分界线</p><h1 id="lec-9-reliable-data-transport-rdt"><a class="markdownIt-Anchor" href="#lec-9-reliable-data-transport-rdt"></a> Lec 9. Reliable Data Transport (RDT)</h1><p>RDT: <strong>Error-free</strong> + Bits received in the <strong>same order</strong></p><p><strong>Network Layer</strong> may have faults (bit errors, missing segments, out-of-order of segments)</p><p>==&gt; guarantee RDT at <strong>Transport Layer</strong> (因为Network Layer可能出错，所以在Transport Layer中保证reliability)</p><p>RDT Tools</p><ul><li><code>ACK</code>: <strong>positive</strong> acknowledgement, <code>NAK</code>: <strong>negative</strong> acknowledgement</li><li>checksum</li><li>Time expiration</li><li>Retransmission</li><li>Sequence number</li></ul><h2 id="stop-and-wait-rdt-protocol"><a class="markdownIt-Anchor" href="#stop-and-wait-rdt-protocol"></a> Stop-and-wait RDT protocol</h2><p>每次只发送一个segment</p><p><strong>S&amp;W version 1</strong>: Checksum, ACK, NAK</p><ul><li>发送一个segment和checksum之后，等待收到ACK/NAK回复，再发送下一个</li></ul><p><strong>S&amp;W version 2</strong>: Checksum, ACK, NAK, <strong>1-bit sequence number</strong></p><ul><li><p>sequence number 是0或1，下一个segment的sequence number是上一个的比特反转</p></li><li><p>能解决duplicate</p><img src="/2025/056_cmu_14740/swv2.webp" srcset="/img/loading.gif" lazyload></li></ul><p><strong>S&amp;W version 3</strong>: Checksum, ACK, NAK, 1-bit sequence number, <strong>timers</strong></p><ul><li><p>解决超时一直收不到ACK/NAK回复，发送方会一直等待的问题</p></li><li><p>sequence number可以解决<strong>premature timeout</strong>(过早超时)导致的duplicate</p><img src="/2025/056_cmu_14740/swv3.webp" srcset="/img/loading.gif" lazyload></li></ul><h2 id="sliding-window-protocols"><a class="markdownIt-Anchor" href="#sliding-window-protocols"></a> Sliding Window Protocols</h2><p>上面的Stop-and-wait Utilization很低，可以使用pipeline提高利用率</p><p>Sender and Receiver agrees on N <strong>(N = size of the sliding window)</strong></p><p>GBN和SR</p><ul><li><strong>Go-Back-N (GBN)</strong><ul><li><strong>Sender</strong>维护一个滑动窗口 (只有发送方维护窗口，接收方没有窗口，只能顺序接收)</li><li>ACK(n)代表所有&lt;=n sequence number的segment都已经收到，大于n的可能未收到</li><li>e.g. 如果发送1,2,3…10，第6个未收到，则6,7,8,9,10都需要重传</li><li>Receiver没有buffering, 不支持接收out-of-order的segment，如果接收到的segment未按照顺序则会被丢弃</li><li><strong>minimal state at the ends, especially receiver end</strong>: Receiver只需要维护last Seq# ACKed</li><li>但是一个segment error可能导致很多segment需要重发，因为乱序发送的packet即使正确也已经被丢弃</li><li><img src="/2025/056_cmu_14740/GBN.webp" srcset="/img/loading.gif" lazyload></li></ul></li><li><strong>Selective Repeat (SR)</strong><ul><li>两个window，发送方和接收方各一个</li><li>每一个segment各需要一个ACK，ACK不一定连续，可以out-of-order</li><li>发送方对每个segment设置timeout，如果超时则重新发送这个segment</li><li>发送方收到ACK(n)后，如果n是尚未收到ACK的最小元素，则可以向右移动窗口(移动send_base指针)</li><li>接收方接收到Seg(n)会发送ACK(n)，如果乱序则buffer/store，如果顺序正确则移动窗口 (deliver all buffered, in-order segments and advance window to not-yet-received segment)</li><li><img src="/2025/056_cmu_14740/sr-window.webp" srcset="/img/loading.gif" lazyload></li><li>SR的问题: 发送方和接收方对window的看法不同</li><li>Solution: 避免接收方的最大Seq #和发送方最小Seq #产生overlap</li><li>Seq # space至少要有两倍window size</li></ul></li></ul><h1 id="lec-10-tcp"><a class="markdownIt-Anchor" href="#lec-10-tcp"></a> Lec 10. TCP</h1><h2 id="overview"><a class="markdownIt-Anchor" href="#overview"></a> Overview</h2><p>TCP: <strong>Transmission Control Protocol</strong></p><ul><li><strong>Point-to-point</strong>: 点对点，一个发送者一个接收者</li><li><strong>Reliable</strong> (RDT): 数据顺序正确，没有segment loss或duplicates。使用pipeline和滑动窗口。</li><li><strong>Full duplex data transfer</strong>: client和server可以双向传输</li><li><strong>Connection-oriented</strong>: 在发送任何数据之前需要handshake建立连接</li></ul><p>TCP用两种方法限制同时能发送的segment数量</p><ul><li><strong>Flow control</strong>: 至于接收方的资源（window size N）有关，发送方要确保不要发太多了让接收方吃不消</li><li><strong>Congestion control</strong>: 与网络有关，发送方要尽量不让network产生congestion阻塞</li></ul><h2 id="tcp-segment"><a class="markdownIt-Anchor" href="#tcp-segment"></a> TCP Segment</h2><img src="/2025/056_cmu_14740/tcp-segment.webp" srcset="/img/loading.gif" lazyload><p>TCP Header 包含至少5个 32-bit words，如果有header中有<code>options</code>则长度会大于5x32-bit.</p><ul><li><p>Source Port #, Destination Port # 各占 16-bit</p></li><li><p>Sequence # 和 Acknowledgement # 各占 32-bit，以 <strong>Bytes of Data</strong> 编号，而不是按 segment 数量编号</p><p><strong>Seq #</strong>: number of the <strong>first byte</strong> in the segment to be sent</p><p><strong>Ack #</strong>: number of the <strong>next expected byte</strong> by the receiver. (隐性告诉发送方所有之前的bytes都已成功收到)</p></li><li><p>In TCP, <strong>ACKs are cumulative</strong></p></li><li><p>hdr len: 共4-bit，代表header的长度，以32-bit为单位，通常值为5，如果有options则大于5</p></li><li><p>Flags:</p><ul><li><strong>ACK</strong>: 确认收到，与ACK #有关</li><li><strong>SYN</strong>: 建立TCP连接，发送方与接收方同步sequence number和receive window</li><li><strong>RST</strong>: Reset 重置TCP连接</li></ul></li><li><p><strong>Receive window</strong>: 单位为bytes，代表接收方期望每次能接收到多少数据不用发送ACK，由接收方的window size决定。会被用作<strong>TCP Flow Control</strong></p></li><li><p>checksum: 纠错</p></li><li><p>Options包括 <strong>Maximum Segment Size (MSS)</strong>: 同一个TCP segment最大能够包含的application layer data大小</p></li></ul><h2 id="tcp-connection-management"><a class="markdownIt-Anchor" href="#tcp-connection-management"></a> TCP Connection Management</h2><p><strong>TCP 三次握手</strong></p><ul><li>Step 1: Client发送<strong>SYN</strong> (包含SYN的TCP segment)，指定Client使用的最初的<strong>Seq #</strong> (client_isn)</li><li>Step 2: Server回复<strong>SYN, ACK</strong>, 创建buffer space (window size)，指定Server使用的最初的 <strong>Seq #</strong> (server_isn), 并acknowledge client_isn+1 (代表已经收到截止client_isn字节的segments，期望下次接收到client_isn+1字节) 此时仍然不发送任何data</li><li>Step 3: Client回复 <strong>ACK</strong>, 并 acknowledge server_isn+1. 此时可能包含data</li></ul><p><strong>TCP 关闭连接</strong></p><ul><li><p>Step 1: Client发送 <strong>FIN</strong></p></li><li><p>Step 2: Server回复ACK，并发送FIN</p></li><li><p>Step 3: Client收到FIN，并回复ACK，进入 <strong>timed wait</strong> state</p><ul><li><p>为什么client已经收到Server的FIN还需要timed wait才会关闭连接？</p><p>因为client回复的ACK可能未成功发送给Server，Server因为无法收到回复会重新发送FIN。如果下次client在相同的端口重新开启连接会收到server重发的FIN，导致刚建立连接就被关闭</p><p>Timed wait state lets TCP resend the final ACK in case this ACK is lost. Any segment that arrives during this time is discarded.</p></li></ul></li><li><p>Step 4: Server收到ACK</p></li></ul><img src="/2025/056_cmu_14740/tcp-close-connection.webp" srcset="/img/loading.gif" lazyload title="TCP Close Connection"><h2 id="tcp-reliable-data-transport"><a class="markdownIt-Anchor" href="#tcp-reliable-data-transport"></a> TCP Reliable Data Transport</h2><p>TCP RDT</p><ul><li>TCP只使用ACK，不像Lec9的RDT一样使用NAK</li><li>TCP is <strong>pipelined</strong> (sliding window)</li><li><strong>cumulative ACKs</strong></li><li><strong>retransmission timer</strong> (timeout events)</li><li><strong>buffers on both sides</strong> (接收方buffer乱序的segments)</li></ul><p>Is TCP a GBN or SR? <strong>between them</strong></p><ul><li>TCP对于认为传输失败的segment，只传输那一个segment，而不传输整个window</li><li>TCP接收方buffers out-of-order segments，但ACK能表示missing的Sequence number</li></ul><h1 id="lec-11-tcp-flow-congestion-control"><a class="markdownIt-Anchor" href="#lec-11-tcp-flow-congestion-control"></a> Lec 11. TCP Flow &amp; Congestion Control</h1><p>TCP用两种方法限制同时能发送的segment数量</p><p>Flow control 取决于接收方，Congestion control 取决于network</p><h2 id="flow-control"><a class="markdownIt-Anchor" href="#flow-control"></a> Flow Control</h2><p>Receiver allocates a <strong>Receive buffer</strong> of size <strong>RcvBuffer</strong>, and a <strong>Receive Window</strong> of size <strong>RcvWindow</strong>.</p><p><strong>RcvWindow</strong> 会告诉sender(在TCP segment header里)</p><p>RcvWindow = RcvBuffer - | LastByteReceived - LastByteRead |</p><h2 id="congestion-control"><a class="markdownIt-Anchor" href="#congestion-control"></a> Congestion Control</h2><p>Network Congestion (Definition): Too many sources (nodes) sending too much data too fast for a network (e.g. intermediate routers) to handle.</p><p>想要: large throughput AND small delay.</p><p>Two options for feedback: <strong>network assisted</strong>, <strong>end-to-end</strong></p><ul><li>network assisted 中, routers会把congestion情况的feedback给sender，告知sender explicit max send rate</li><li>end-to-end中，只从终端获取losses和delays</li><li>TCP选择end-to-end</li></ul><h2 id="tcp-congestion-control"><a class="markdownIt-Anchor" href="#tcp-congestion-control"></a> TCP Congestion Control</h2><p><code>CongWin</code> (发送方维护的一个变量)</p><p>LastByteSend - LastByteAcked &lt;= <code>CongWin</code></p><p>Roughly, TCP Send rate = CongWin/RTT</p><p><strong>End-to-end loss segment events</strong></p><ul><li>Segment <strong>timeout</strong></li><li><strong>Three duplicate ACKs</strong></li></ul><p>发现loss segment event时江都send rate (<code>CongWin</code>)，未发现时增加send rate</p><p>TCP is <strong>self-clocking</strong> (does not receive explicit feedback from other nodes)</p><p>有多个TCP Congestion Control的算法，今天讲 <strong>TCP Tahoe</strong> 和 <strong>TCP Reno (most widely used)</strong></p><p><strong>TCP Congestion Control Phases/States</strong></p><ol><li><p><strong>slow start</strong></p><ul><li>开始时，<code>CongWin</code> = 1MSS (Max Segment Size)</li><li>exponentially fast 每次乘2，指数级增长</li><li>直到发生loss event，或超过 <code>ssthresh</code> (<code>ssthresh</code> = Slow Start Threshold)</li></ul></li><li><p><strong>congestion avoidance</strong></p><ul><li><strong>Additive Increase, Multiplicative Decrease (AIMD)</strong></li><li>Additive Increase: 每次RTT 加1MSS直到发生loss event</li><li>Multiplicative Decrease: <code>CongWin</code>减半</li><li><strong>Tahoe</strong>不区分timeout和3 dup ack，直接降低到<code>CongWin=1</code> 然后slow start</li><li><strong>Reno</strong> 对于timeout同上，对于3 dup ack让<code>CongWin</code>减半然后线性增长</li><li><code>ssthresh</code> = CongWin / 2 (减半threshold)</li></ul></li><li><p><strong>RTT estimation</strong></p><ul><li><p>timeout的值需要准确设定: 不是常数(与网络拥堵情况有关); 必须比RTT长</p><p>如果timeout太长：slow reaction to segment loss</p><p>如果timeout太短：premature timeout, unnecessary retransmissions 过早超时</p></li><li><p>取多个Sample RTT取平均。</p></li><li><p>必须忽略retransmissions（retransmitted segments的回复不计入RTT，因为无法分清是原包回复还是重发包回复）</p></li><li><p><strong>Exponential Weighted Moving Average (EWMA)</strong>:</p><p>EstimatedRTT_t = (1-alpha) * EstimatedRTT_t-1 + alpha * SampleRTT</p></li><li><p>Timeout = EstimatedRTT + <strong>safety margin</strong></p><p>safety margin也会变，与SampleRTT的方差有关</p></li></ul></li></ol><p>// 上面讲了 TCP Tahoe, TCP Reno</p><img src="/2025/056_cmu_14740/tcp-tahoe-vs-reno.png" srcset="/img/loading.gif" lazyload><h1 id="lec-12-tcp-advanced-congestion-control-end-hosts"><a class="markdownIt-Anchor" href="#lec-12-tcp-advanced-congestion-control-end-hosts"></a> Lec 12. TCP Advanced Congestion Control (End Hosts)</h1><h2 id="tcp-cc-versions"><a class="markdownIt-Anchor" href="#tcp-cc-versions"></a> TCP CC Versions</h2><p>Reno: 对于timeout降低到<code>CongWin=1</code>, 对于3 dup ack将<code>CongWin</code>减半</p><p>TCP Reno的局限性: 可能会多次降低congestion window (对于2次loss event会减半两次，相当于减到1/4，但其实减到1/2已经足够)</p><p><strong>TCP New Reno</strong>: improves <strong>fast recovery</strong> retransmissions</p><ul><li>Fast Recovery中引入 <strong>Partial ACK</strong> 的概念</li><li>Partial ACK: 不acknowledge CongWin里全部Segment的ACK</li><li>New Reno在high error rates的场景下显著比Reno表现更好</li></ul><p><strong>TCP Vegas</strong></p><ul><li>之前讲的Tahoe, Reno, New Reno都是<strong>loss-based</strong>: 对于loss event (timeout或3 dup ack)做出反应</li><li>TCP Vegas是首个<strong>delay-based</strong> TCP variant</li><li>根据RTT的时长判断congestion, 如果RTT小于expected, 增加<code>CongWin</code>, 否则减少<code>CongWin</code></li><li>相比Reno, much smoother data flow; higher average throughput</li><li>但是 only ~2/3 of Reno’s total bandwidth，原因是Vegas在congestion前back off，Reno在congestion后back off</li></ul><p><strong>TCP Hybla</strong></p><ul><li>Goal: 在高延迟、高错误率场景下提高效率</li><li>TCP Hybla analytically evaluates <code>CongWin</code> dynamics, 而不是直接测量RTT</li></ul><p><strong>LFN (Long Fat Networks)</strong> problem</p><ul><li><p><strong>high speed</strong>/bandwidth, <strong>high latency</strong>/delay</p></li><li><p>典型的congestion avoidance在LFN上表现不好，解决办法是more aggressive: get lots of segments in flight</p></li><li><p><strong>TCP-BIC</strong> (binary increase congestion) / <strong>CUBIC</strong>: 用二分查找查找出bandwidth（而不是每次RTT加1个MSS）</p><ul><li><code>Target CongWin = (max + min) / 2</code></li><li>如果当前<code>CongWin</code>增大到<code>target</code>, 则<code>min = target</code>, 重新计算<code>target</code></li><li>如果发生loss, 则<code>max = current</code>, <code>min = recovery point</code> (二分之一处), 重新计算<code>target</code></li></ul></li><li><p><strong>Fairness</strong>: 同一个network(例如同一套intermediate routers)加上可以同时建立多个TCP连接，每个TCP连接可以采用不同的CC算法。一个<strong>overly aggressive</strong> TCP CC algorithm会抢占别人的带宽。</p></li></ul><p><strong>Compound TCP (CTCP)</strong></p><ul><li><p>A <strong>hybrid of loss-based and delay-based</strong> algorithms</p></li><li><p>没有congestion的时候变得更aggressive，发现congestion时考虑对其它CC的公平性更加缓和</p></li><li><p>key idea: 同时使用一个loss-based congestion window <code>cwind</code> 和 delay-based congestion window <code>dwind</code></p><ul><li><p><code>CTCP Total CongWin = cwind + dwind</code></p></li><li><p><code>cwind</code>由AIMD正常更新: 没有loss时<code>cwind</code>每个RTT增加1MSS，有loss时减半</p></li><li><p>观察RTT，如果带宽underutilized, 则</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>w</mi><mi>i</mi><mi>n</mi><mi>d</mi><mo stretchy="false">(</mo><mi>t</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>d</mi><mi>w</mi><mi>i</mi><mi>n</mi><mi>d</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>+</mo><mi>α</mi><mo>⋅</mo><mi>d</mi><mi>w</mi><mi>i</mi><mi>n</mi><mi>d</mi><mo stretchy="false">(</mo><mi>t</mi><msup><mo stretchy="false">)</mo><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">dwind(t+1) = dwind(t) + \alpha \cdot dwind(t)^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:.02691em">w</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:.02691em">w</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.44445em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.0037em">α</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-.25em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:.02691em">w</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8991079999999999em"><span style="top:-3.113em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03148em">k</span></span></span></span></span></span></span></span></span></span></span></span></p></li><li><p>如果检测到queueing，代表开始发生congestion，则</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>w</mi><mi>i</mi><mi>n</mi><mi>d</mi><mo stretchy="false">(</mo><mi>t</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>d</mi><mi>w</mi><mi>i</mi><mi>n</mi><mi>d</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>−</mo><mi>q</mi><mi>u</mi><mi>e</mi><mi>u</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">dwind(t+1) = dwind(t) - queue\_length</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:.02691em">w</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:.02691em">w</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-.31em"></span><span class="mord mathnormal" style="margin-right:.03588em">q</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mord" style="margin-right:.02778em">_</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span></span></span></span></span></p></li><li><p>如果发生loss event，则</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>w</mi><mi>i</mi><mi>n</mi><mi>d</mi><mo stretchy="false">(</mo><mi>t</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>β</mi><mo stretchy="false">)</mo><mi>d</mi><mi>w</mi><mi>i</mi><mi>n</mi><mi>d</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dwind(t+1) = (1-\beta) dwind(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:.02691em">w</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.05278em">β</span><span class="mclose">)</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:.02691em">w</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span></span></p></li><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo separator="true">,</mo><mi>β</mi><mo separator="true">,</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\alpha, \beta, k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.0037em">α</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.05278em">β</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span></span></span></span>可调节。queue_length的预测较为复杂，不讲</p></li></ul></li></ul><h2 id="prisoners-dilemma"><a class="markdownIt-Anchor" href="#prisoners-dilemma"></a> Prisoner’s Dilemma</h2><p>Flow Control: 接收方显式告诉发送方最大能发送多少东西（size of receiving window)</p><p>Congestion Control: 发送方推断或观察congestion情况来决定发送多少东西</p><p>TCP is “<strong>self-clocking</strong>”: send rate由smallest window (either flow or congestion windows) 和接收到的event (receive window, ack, timers, 3 dup acks)决定</p><p><strong>Fairness</strong>: 如果一个TCP flow非常aggressive，会导致别的flows产生loss，别的flow会back off降低自己的带宽，这进一步导致aggressor抢占更多的带宽</p><p><strong>Prisoner’s Dilemma</strong>:</p><ul><li>两名罪犯分开审讯，两人都沉默：各蹲6个月；两人都背叛：各蹲5年；一人背叛一人沉默：背叛者释放，沉默者蹲10年</li></ul><h2 id="quic-a-new-transport-layer-protocol"><a class="markdownIt-Anchor" href="#quic-a-new-transport-layer-protocol"></a> QUIC: a new “transport” layer protocol</h2><p>TCP的问题：</p><ul><li>Header不加密</li><li>单一stream of data</li><li>需要多个RTT (三次握手等)</li></ul><p>QUIC</p><ul><li>2012年google开发</li><li>still <strong>based on UDP</strong>, 降低handshake时间至1RTT，从协议层面加密数据</li><li><strong>Multi-stream connections</strong><ul><li>一个<strong>QUIC connection</strong>可由多个<strong>QUIC stream</strong>组成，QUIC stream管理数据交换。每个stream都是独立的，各自管理自己的flow control、丢包数据重传等，由stream ID标记</li><li>一个<strong>QUIC packet</strong>包含一个或多个<strong>QUIC Frame</strong>, QUIC Frame是ACK, CRYPTO, STREAM等</li><li>flow control很类似TCP</li></ul></li><li><strong>0-RTT connection</strong><ul><li>握手只需要消耗0RTT，因为第一条<strong>Client Hello</strong>握手消息已经包含请求(encryption details和HTTP method)，第一条Server Hello (服务器回复)已经包含返回的数据(和security相关的数据)。这些信息在多个QUIC packets和QUIC frames同时传递。</li><li><img src="/2025/056_cmu_14740/quic-0-rtt.png" srcset="/img/loading.gif" lazyload></li></ul></li><li>QUIC在大部分场景比TCP更好，尤其是high latency和high packet loss的场景</li><li>QUIC的缺点是jitter会导致packet reordering, 以及large data transfers情况下QUIC提升不明显，在少量数据传输时QUIC才体现优势</li></ul><h1 id="lec-13-the-network-layer"><a class="markdownIt-Anchor" href="#lec-13-the-network-layer"></a> Lec 13. The Network Layer</h1><h2 id="network-layer"><a class="markdownIt-Anchor" href="#network-layer"></a> Network Layer</h2><p>IP那一层就在Network Layer (recap: <strong>hourglass model</strong>)</p><p>Service: move a <strong>packet</strong> from Sending Host to Receiving Host (Logical <strong>host-to-host</strong> connection)</p><ul><li><strong>不同于Transport Layer</strong>: Transport Layer是application-to-application / process-to-process;</li><li>Transport Layer只在end hosts中有implementation，而Network Layer在end hosts和intermediate routers中都有implementation</li></ul><p>Network Layer key functions</p><ul><li><strong>routing (control plane)</strong>: 判断end-to-end paths/routes<ul><li>routing is the process of <strong>creating and maintaining Forwarding Tables</strong> at <strong>all</strong> routers</li><li>需要在所有router内建立forwarding table</li></ul></li><li><strong>forwarding (data plane)</strong>: 将packet从一个router的incoming interface/link移动到另一个outgoing router’s interface/link<ul><li>forwarding <strong>determines the output link for each incoming packet</strong></li><li>an action in a <strong>single router</strong>. 会使用到forwarding table</li></ul></li><li><strong>connection setup</strong>: 有些networks（不是IP）需要router内有state initialization</li></ul><h1 id="ip-internet-protocol"><a class="markdownIt-Anchor" href="#ip-internet-protocol"></a> IP: Internet Protocol</h1><p>IP的三个主要部件(packet switching)</p><ol><li>Internet Protocol (IP)</li></ol><ul><li><p>定义了<strong>datagram/packet header format</strong>, header由以下部分组成</p><ul><li><p><code>Version</code>: IPv4/IPv6</p></li><li><p>Header length (<code>Hdr Len</code>) 单位为32-bit words，通常为5 (代表20bytes) + options (options很少使用)</p></li><li><p>Type of Service (<code>ToS</code>): 很少使用</p></li><li><p><code>Datagram Length</code> (Header+Data)的长度，单位为byte。理论最大值为65536 bytes，通常小于1500bytes</p></li><li><p><code>ID</code> (16-bit identifier), <code>Flags</code>, <code>Offset</code> (13-bit fragment offset): 用于router的<strong>fragmentation</strong></p></li><li><p><code>TTL</code>: 每经过一个router这个值减1，如果TTL=0则drop这个datagram</p></li><li><p><code>Protocol</code>: 决定Transport Layer中的哪个协议应该解包得到里面的segment (例如TCP)</p></li><li><p><code>Header checksum</code>: 与UDP的计算方式相同，只对于header计算。header checksum每个router都必须重新计算，因为TTL减1会导致checksum发生变化</p></li><li><p><code>IP Addresses</code> (unique host identifiers): 包含source和dest，对于IPv4此处为32-bit</p></li><li><p><code>Options</code>: 很少使用</p></li><li><p><code>Data</code>: 封装后的TCP/UDP segment</p></li><li><img src="/2025/056_cmu_14740/IP-header.png" srcset="/img/loading.gif" lazyload></li></ul></li><li><p>不同的connections/links会有不同的<strong>Max Transmission Unit (MTU)</strong> limitations。一个IP packet传输需要经过多重不同的link conditions</p></li><li><p>如果MTU太小了，一个IP Datagram/Packet装不下，则需要<strong>fragment</strong>将原有packet分散成更小的、能放入outbound link的MTU的IP packets</p></li><li><p>上面IP header的构成中，</p><ul><li><code>Identifier</code> (16-bit) : 一个packet的每个fragment有unique value，由fragment的router随机生成</li><li><code>Flags</code>: <code>DF</code> 代表 do not fragment, 如果packet对于MTU太大了，则drop并发送ICMP error message回去；<code>MF</code> 代表 more fragments are expected after this fragment, 除了最后一个fragment以外值都是1</li><li><code>Offset</code> (13-bit): fragment相对于packet开头的偏移量，单位为8-byte</li></ul></li><li><p>Fragment的Reassembly（重新组装）只在接收方做，这样能减轻intermediate router的负担。如果任何一个fragment丢了，则所有fragment都会被discard</p></li></ul><ol start="2"><li><p>Routing Protocols</p></li><li><p>Forward Protocols</p></li></ol><h2 id="ip-addressing"><a class="markdownIt-Anchor" href="#ip-addressing"></a> IP Addressing</h2><p>Q: Ethernet (MAC) 地址已经能做到global uniqueness, 为什么network layer不使用MAC地址？</p><p>因为MAC地址不能帮助routing，我们需要一个hierarchical address, 帮助locate devices</p><p>IPv4</p><ul><li>32-bit的数字</li><li>192.168开头代表non-routable, 224或239开头代表multi-cast, 255.255.255.255代表broadcast</li><li>IP地址至少由<strong>Network part (prefix)<strong>和</strong>Host part</strong>组成, prefix大小可变</li><li>Original的IP设计只有三个选项：network prefix占用8bits, 16bits或24bits</li></ul><p><strong>Subnetworks</strong></p><ul><li>organizations会使用subset来将大network分成小的subnetworks，每个subnet内可以直接通信，router用于跨subnet间的通信</li><li>所有subnetwork内的所有host使用相同的network prefix</li></ul><p><strong>IP address prefix notation and range</strong></p><p>e.g. <code>128.2.101.64/26</code> 代表固定前26 bit，后6个bit可以自由发挥，所以代表 <code>128.2.101.64</code> (01000000) 到 <code>128.2.101.127</code> (01111111) 的IP地址范围</p><p><strong>IP forwarding table</strong></p><ul><li>forwarding table把destination IP address map到outgoing link/interface的编号</li><li><strong>prefix matching - longest prefix matching rule</strong><ul><li>table中不需要enumerate所有地址</li><li>一个IP地址可能会match到多个table entry，选择prefix能match位数最多的</li></ul></li></ul><h1 id="lec-14-routing-algorithms"><a class="markdownIt-Anchor" href="#lec-14-routing-algorithms"></a> Lec 14. Routing Algorithms</h1><p>Recall: routing, forwarding</p><h2 id="routing-theory-graphs"><a class="markdownIt-Anchor" href="#routing-theory-graphs"></a> Routing theory: graphs</h2><p>Internet由<strong>routers</strong> (位于<strong>core</strong> of network) 和<strong>end devices</strong> (位于<strong>edge</strong> of network)组成</p><ul><li><p><strong>Internet core</strong> 能用Graph <strong>G = (N, E)</strong> 来建模表示</p><p><strong>N</strong>: set of <strong>routers</strong> (nodes)</p><p><strong>E</strong>: set of <strong>links</strong> connecting routers (nodes)</p></li></ul><p><strong>Link and Path Costs</strong></p><ul><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><msub><mi>N</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>N</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">c(N_1, N_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>: 两个节点之间的<strong>link cost</strong>。如果这两个节点没有直接连接，就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infin</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord">∞</span></span></span></span></p></li><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo stretchy="false">(</mo><msub><mi>N</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>N</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>N</mi><mi>p</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>c</mi><mo stretchy="false">(</mo><msub><mi>N</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>N</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>c</mi><mo stretchy="false">(</mo><msub><mi>N</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>N</mi><mn>3</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mo>⋯</mo></mrow><annotation encoding="application/x-tex">C(N_1, N_2, \cdots, N_p) = c(N_1, N_2) + c(N_2, N_3) + \cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-.286108em"></span><span class="mord mathnormal" style="margin-right:.07153em">C</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.15139200000000003em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.31em;vertical-align:0"></span><span class="minner">⋯</span></span></span></span>: 代表<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">N_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">N_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.969438em;vertical-align:-.286108em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.15139200000000003em"><span style="top:-2.5500000000000003em;margin-left:-.10903em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span></span></span></span>之间的<strong>path cost</strong></p></li><li><p>Routing algorithm: 找到任意两个节点的<strong>least-cost path</strong></p><p>router会在forwarding table上存储哪个outgoing link/interface由least-cost path</p></li></ul><p><strong>Routing Algorithm 分类</strong>: Link State (LS) 和 Distance Vector (DV) algorithms</p><h2 id="link-state-ls-algorithms-global"><a class="markdownIt-Anchor" href="#link-state-ls-algorithms-global"></a> Link State (LS) algorithms (global)</h2><ul><li><p>global意思是 All routers know all.</p></li><li><p>所有routers都有完整的global network拓扑结构的认识</p></li><li><p>所有router各自算出到其它所有节点的least-cost paths</p></li><li><p><strong>Link State Flooding</strong>: 每个node发送它的LS信息给所有直接连接的邻居 (known as <strong>Link State Advertisement (LSA)</strong>，每个节点relay LSA信息给自己的所有邻居</p><p>Flood之后，每个router各自计算到其它所有router的最好路径。属于<strong>deterministic algorithm</strong>: 所有router计算出来的结果是相同的。</p><p>常用方法有<strong>Dijkstra’s</strong> algorithm:</p><ul><li>每个节点算出其它所有节点的 D(node), p(node). D()是距离，p()的意思是下一步往哪走。</li><li>==&gt; <strong>Shortest Path Tree (SPT)</strong></li><li>因为要记录所有节点，复杂度 O(n^2), 有更efficient的算法 O(n logn)</li></ul></li></ul><h2 id="distance-vector-dv-algorithms-decentralized-local"><a class="markdownIt-Anchor" href="#distance-vector-dv-algorithms-decentralized-local"></a> Distance Vector (DV) algorithms (decentralized &amp; local)</h2><ul><li><p>每个router只有local knowledge，只了解到neighbors和到neighbors的link cost</p></li><li><p><strong>message exchange</strong> 替代LS flooding</p></li><li><p>每个节点只和邻居传递 <strong>distance vector (DV)</strong>: DV是一个一维数组，写的是自己到其它节点的cost</p></li><li><p>Iterative: 每次local iteration (exchange DV) 只会在以下时候发生</p><ul><li>local link cost改变（节点到与之直接连接的邻居距离发生改变）</li><li>收到邻居发来的DV update message</li></ul></li><li><p><strong>Distributed</strong>: 每个节点自动用local knowledge计算routes</p></li><li><p>每个节点循环做: 等待邻居发来DV更新，重新计算，如果到任意节点的DV发生改变则通知邻居。直到<strong>convergence</strong></p></li><li><p><strong>Bellman-Ford (BF)</strong> equation: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>x</mi></msub><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo><mi>min</mi><mo>⁡</mo></mo><mi>v</mi></msub><mo stretchy="false">{</mo><mi>c</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>d</mi><mi>v</mi></msub><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">d_x(y) = \min_v \{c(x,v) + d_v(y)\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.03588em">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mop"><span class="mop">min</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03588em">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mopen">{</span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03588em">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.03588em">y</span><span class="mclose">)</span><span class="mclose">}</span></span></span></span></p><p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>min</mi><mo>⁡</mo></mo><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">\min_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.81786em;vertical-align:-.15em"></span><span class="mop"><span class="mop">min</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03588em">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 指的是节点x的所有邻居节点v拥有最小cost的那个</p></li><li><p>“Good news travels fast”, “Bad news travels slowly”</p><p>如果某一条路径突然中断，会导致DV里某一个值逐渐增大，趋向于无穷</p></li><li><p>解决count-to-infinity的两种方法</p><ul><li><p><strong>split horizon</strong>: don’t send routes back from where it learned the route</p><p>当A告诉B更新后的DV，B更新完会告诉所有neighbor但不返回给A</p></li><li><p>split horizon with <strong>poisoned reverse</strong></p><p>Nodes advertise the cost of infinity for a dest to the neighbor it routes through to reach that destination</p></li><li><p>也可以<strong>redefine infinity</strong>，定义 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.07153em">C</span></span></span></span>=max cost, 大于C即认为是无穷</p></li><li><p>Unfortunately, 节点数大于3时，没有方法能彻底解决count-to-infinity问题</p></li></ul></li></ul><h2 id="ls-dv-对比"><a class="markdownIt-Anchor" href="#ls-dv-对比"></a> LS, DV 对比</h2><ul><li>Message complexity<ul><li>LS: n个节点，E条边，总共需发送O(nE)条信息</li><li>DV: 只于邻居传输</li></ul></li><li>Converge速度<ul><li>LS: After the correct message exchange (flooding)</li><li>DV: Varies. 可能出现routing loops.</li></ul></li><li>Robustness: 一个router坏掉时会发生什么<ul><li>LS和DV中 node都有可能advertise出不正确的link cost</li></ul></li></ul><h1 id="lec-15-network-layer-internet-routing"><a class="markdownIt-Anchor" href="#lec-15-network-layer-internet-routing"></a> Lec 15. Network Layer: Internet Routing</h1><h2 id="hierarchical-routing"><a class="markdownIt-Anchor" href="#hierarchical-routing"></a> Hierarchical Routing</h2><p>完整的Internet有众多的organizations和routers，用LS或DV routing algorithm几乎永远无法converge</p><p>Solution: <strong>Hierarchical Routing</strong></p><p><strong>Autonomous System (AS)</strong></p><ul><li><p>AS: a collection of physical networks with a <strong>unified adiministrative routing policy</strong> (同一个administration下的routers，例如ISP、校园网)</p></li><li><p>AS的内部自由选择routing算法，AS与别的AS之间使用标准</p><ul><li><p>With AS: Intra-domain routing, <strong>Interior Gateway Protocol (IGP)</strong></p></li><li><p>Between AS: Inter-domain routing, <strong>Exterior Gateway Protocol (EGP)</strong></p><p>Between AS之间需要 <strong>Border Gateways</strong> (Border routers)</p></li></ul></li></ul><p><strong>Autonomous System Number (ASN)</strong></p><ul><li>ASN identifies AS on the Internet</li><li>曾经16-bits，现在是32-bits</li><li>一个AS可以有一个ASN，多个ASN，或没有ASN（例如家庭宽带使用ISP的ASN）</li></ul><img src="/2025/056_cmu_14740/routing-protocols.png" srcset="/img/loading.gif" lazyload><h1 id="igp"><a class="markdownIt-Anchor" href="#igp"></a> IGP</h1><p><strong>OSPF: Open Shortest Path First</strong></p><ul><li>Link State (LS) routing算法的一种实现</li><li>Dijkstra算法, Flooding messages are <strong>broadcast</strong> inside network</li><li>使用IP Port number 89</li><li>Open 意为 <strong>non-proprietary</strong></li><li>Link weights (link costs) 可由管理员定义（例如: Inverse bandwidth, RTT, congestion level等）==&gt; <strong>no policy, just mechanisms</strong></li><li>一个AS下可以创建多个不同的 <strong>OSPF routing areas</strong><ul><li><strong>area border routers (gateways)</strong> 将不同routing areas相连</li><li>area border routers在<strong>backbone area</strong>相连</li><li>Flooding只会在一个routing area内部发生</li></ul></li></ul><img src="/2025/056_cmu_14740/ospf-hierarchy.png" srcset="/img/loading.gif" lazyload><p><strong>IS-IS: Intermediate System to Intermediate System</strong></p><ul><li>一个LS algorithm。常用于large ISP.</li><li>相比于OSPF，flood的消息数量更少；能scale同时用于IPv4和IPv6（作为对比，OSPF为IPv4设计，需要大量修改才能用于IPv6）</li><li>Runs on top of <strong>data link layer</strong></li></ul><p><strong>Routing Information Protocol (RIP)</strong></p><ul><li><p>DV routing algorithm</p></li><li><p>Link weight (cost) 始终为1，path cost是number of hops，定义最大Path Cost C=15来限制count-of-infinity问题</p></li><li><p>Routers定期(每30秒)发送RIP advertisement message 即Distance vectors。</p><p>RIP message也用于向邻居请求指定的route信息</p></li><li><p>Sent over <strong>UDP port 520</strong></p><p>RIP是一个Application Layer的进程，用Transport Layer发送消息，但RIP消息可以更改位于router的forwarding table，即可以更改底层Network Layer的信息</p></li></ul><p><strong>IGRP: Internal Gateway Routing Protocol</strong></p><ul><li>类似于RIP的一种DV Cisco protocol</li><li>与RIP的区别是可以link weight使用别的metrics (不同于hop count)</li></ul><p><strong>EIGRP: Enhanced Interior Gateway Routing Protocol</strong></p><ul><li>A proprietary Cisco routing protocol</li><li>EIGRP use metrics from <strong>both DV and LS</strong> protocols (<strong>hybrid</strong>) 来实现更快的convergence和更少的资源占用</li></ul><h2 id="egp"><a class="markdownIt-Anchor" href="#egp"></a> EGP</h2><p>IGP底下有好多种, 但是EGP底下只有一个（因为需要globally使用，如果多种多样会“语言不通”）</p><p><strong>Border Gateway Protocol (BGP)</strong></p><ul><li><p>使用 path-vector routing algorithm</p></li><li><p>heavily <strong>policy-based</strong>, simple protocol, but configuration is complex.</p></li><li><p><strong>BGP Border Gateways (routers)</strong> 之间会建立<strong>BGP session</strong></p><p>使用TCP port 179与邻居AS交换routing信息</p></li><li><p>BGP message types</p><ul><li><code>OPEN</code>: Border routers间开启BGP session/connection</li><li><code>KEEPALIVE</code></li><li><code>NOTIFICATION</code>: 发生错误需要关闭TCP连接，关闭TCP连接前先发一条notification</li><li><code>UPDATE</code>: 最主要的消息类型, 传输routes和paths信息(例如向别人广播自己的network prefixes)<ul><li>Announce routes/paths: <strong>Route = Network Prefix + [Path Attributes]</strong></li></ul></li></ul></li><li><p>eBGP (externel BGP) 和 iBGP (internal BGP)</p><ul><li>eBGP: 位于不同AS的router间建立</li><li>iBGP: 同一个AS下的router间建立，通常为全连接 complete mesh topology</li></ul></li></ul><h2 id="bgp-path-attributes"><a class="markdownIt-Anchor" href="#bgp-path-attributes"></a> BGP Path Attributes</h2><p>TODO</p><h1 id="lec-16-dhcp-nat-and-ipv6"><a class="markdownIt-Anchor" href="#lec-16-dhcp-nat-and-ipv6"></a> Lec 16. DHCP, NAT, and IPv6</h1><h2 id="dhcp-dynamic-host-configuration-protocol"><a class="markdownIt-Anchor" href="#dhcp-dynamic-host-configuration-protocol"></a> DHCP (Dynamic Host Configuration Protocol)</h2><p>用于在client和server之间交换<strong>network configuration data</strong>.</p><p>network configuration data 包括 <strong>client’s IP address</strong>, DNS服务器地址, 代理地址等</p><p>通常client是刚刚连接到网络的新设备。新client会发送<strong>DHCP request</strong>, 然后 <strong>DHCP server</strong>回复</p><p>每个DHCP server都存储了一个IP地址池子 (满足组织内IP地址前缀要求)</p><p>IP Allocation to Clients</p><ul><li><strong>dynamic allocation</strong>: assign(<strong>lease</strong>)一个随机地址, 有时长限制 (<strong>Lease Time</strong>)<ul><li>为什么需要Lease? 因为大部分DHCP Client下线不会通知Server</li></ul></li><li><strong>automatic allocation</strong>: 给一个permanent IP地址</li><li><strong>manual allocation</strong>: 系统管理员决定哪个client给哪个IP地址</li></ul><p>DHCP Client刚进入网络时还不了解网络(包括不了解自己的IP地址)，会<strong>broadcast</strong>给其它所有人, 发送给<strong>255.255.255.255</strong>, 使用UDP 67端口</p><p>DHCP消息有多个Fields</p><ul><li><code>type</code>: 有 <code>Discover</code>, <code>Offer</code>, <code>Request</code>, <code>Ack</code>, <code>Release</code> 类型</li><li><code>xid</code>: 随机的transaction值，用于对应请求和回复</li><li><code>chaddr</code>: Client hardware identifier (address), 与Client的硬件有关, 是MAC地址或其它unique key</li><li><code>siaddr</code>: DHCP Server的IP地址</li><li><code>yiaddr</code>: <strong>Your address</strong> (给client的新IP地址)</li><li><code>Options</code>: 其它可选参数 e.g. 租期时长</li></ul><p><strong>DHCP Process (DORA)</strong></p><ul><li><p>1: Client发送<code>DHCP DISCOVER</code>, broadcast消息来找DHCP server</p></li><li><p>2: Server提供<code>DHCP OFFER</code>, server也broadcast一条消息，其中包含xid和offer给client的IP地址和租期</p><p>可能有多个DHCP服务器都会给client提供offer</p></li><li><p>3: Client接受其中一个offer <code>DHCP Request</code>, 通常broadcast以便让别的服务器知道client已经接受了一个offer</p></li><li><p>4: Server确认client已经接受offer <code>DHCP ACK</code></p></li><li><p>5: Client使用IP地址完成后归还IP地址 <code>DHCP RELEASE</code></p></li></ul><p>Pure-DHCP可能有安全问题</p><ul><li>恶意服务器可以给client发送错误的值，例如假冒DNS服务器</li><li>恶意Client可以让服务器的IP地址池耗尽，进行DoS攻击</li></ul><h2 id="nat-network-address-translation"><a class="markdownIt-Anchor" href="#nat-network-address-translation"></a> NAT (Network Address Translation)</h2><p><strong>NAT</strong> 对内多个private IP地址，对外1个IP地址。也叫做 <strong>IP Masquerading</strong> or <strong>IP Sproofing</strong></p><p>Private networks使用Non-routable 或 Private IP addresses</p><ul><li><code>10.0.0.0/8</code></li><li><code>172.16.0.0/12</code></li><li><code>192.168.0.0/16</code></li></ul><p>NAT router存储一个<strong>NAT Address Translation Table</strong>: Internal IP, Port到External IP, Port的双向映射</p><p>router会修改所有packets，按照翻译表将里面的IP/Port进行修改</p><p>除了修改packet之外可能还要修改别的东西:</p><ul><li>Fix checksums</li><li>FTP等协议在Application Layer的data stream内也有IP地址</li><li>需要重新组装fragmented packets</li></ul><p>Port Forwarding: 端口转发，通常外网不能访问内网设备，端口转发可以提前更改table</p><p>NAT benefits</p><ul><li>解决IPv4耗尽的问题</li><li>内网设备地址分配简单，不需要联系ISP获取额外的IPv4地址</li><li>内网架构外网不可见，安全</li></ul><p>NAT objections</p><ul><li><p>应该用IPv6来解决IPv4耗尽的问题</p></li><li><p>NAT违反了end-to-end principle. 中间的node(路由器)保存了连接状态的state，并会修改数据包</p><p>store and forward是可以的，保留states不可以</p></li><li><p>Router不应该访问或处理高于Network Layer的内容，但IP/Port的修改改了transport Layer（高于network Layer）</p></li><li><p>使用端口号判断host（端口号应用于判断process/applications)</p></li></ul><h2 id="ipv6"><a class="markdownIt-Anchor" href="#ipv6"></a> IPv6</h2><p>128-bit的IP地址</p><p>一个group内的leading zeros可省略，整个IPv6地址中最长的连续0可以省略</p><p>例如 <code>0124:A245:0000:0000:0000:0000:0001:0023</code> 可简写为 <code>124:A245::1:23</code></p><p>IPv6允许任意长度的network prefix size</p><p>特殊地址</p><ul><li><code>FF00</code>开头: Multicast</li><li><code>FE80</code>(<code>1111 1110 10</code>)开头: <strong>link-local</strong> address：内网，不会被路由器转发，不会发送给别的SW</li><li><code>FEC0</code>(<code>1111 1110 11</code>)开头：<strong>site-local</strong> address：never be transmitted beyond a site</li><li>IPv6没有broadcast</li></ul><p>IPv6的header尽可能简化</p><ul><li><p><code>Version</code>: <code>0110</code>代表6</p></li><li><p><code>Traffic Class</code>, <code>Flow Label</code>: 用来判断给哪些data优先传输。如何使用并没有定义</p></li><li><p><code>Payload Length</code> 单位为bytes</p></li><li><p><code>Next Header</code>: 指向下一个header的指针。类似IPv4的<code>Upper Layer Protocol</code>项</p><p>TCP --&gt; 6, UDP --&gt; 17.</p><p>可以像链表一样串多个options headers，最后一个的next header指向payload</p></li><li><p><code>Hop Limit</code>: 就是IPv4中的<code>TTL</code></p></li><li><p>发送方和接收方地址，各占128 bits (16 bytes)</p></li><li><p>总header长度为40bytes（没有可变长度，IPv4因为options会有可变长度）</p></li></ul><p><strong>Stateless auto-configuration</strong> in IPv6 (SLAAC)</p><ul><li>不同于IPv4需要DHCP，IPv6可以auto-configuration，client可以自己选择一个IPv6地址，只要能保证地址无重复</li><li>使用Link-local address prefix (<code>1111 1110 10</code>) 加上一些0加上MAC地址</li><li>可以使用 <strong>IPv6 Neighbor Discovery Protocol (NDP)</strong> 来找其它的网络信息 (next-hop地址，DNS服务器等)</li></ul><p><strong>Stateful configuration</strong></p><ul><li>DHCPv6</li></ul><h1 id="lec-17-network-layer-measurement"><a class="markdownIt-Anchor" href="#lec-17-network-layer-measurement"></a> Lec 17. Network Layer Measurement</h1><h2 id="traffic-measurement"><a class="markdownIt-Anchor" href="#traffic-measurement"></a> Traffic Measurement</h2><p><strong>Why measure?</strong></p><ul><li>Short-term monitoring<ul><li>检测hot spots (issues), 例如congested links, overloaded routers</li><li>检测实时网络攻击, 例如DoS(Denial of Service)</li></ul></li><li>Long-term planning<ul><li>traffic engineering (如果特定AS之间有很多packets交互，则可能要peer一下)</li><li>re-routing traffic (prefer a peer link over a transit link)</li><li>upgrade links</li></ul></li></ul><p><strong>Type of measurements</strong></p><ul><li><strong>passive</strong>: observe network behavior<ul><li>抓捕现有网络流量的数据，直接在end hosts或routers内测量</li><li><strong>When to measure</strong>? Trying to define/obtain desired production traffic characteristics.</li><li>Tools: packet tracers, SNMP, NetFlow, Argus, …</li></ul></li><li><strong>active</strong>: inject probe packets (send data) into the network<ul><li>测量inject之后网络的特性和影响</li><li><strong>When to measure</strong>? When network properties are desired (延迟,抖动,带宽,拓扑结构等)</li><li>Tools: ping, tracert, pchar(曾是pathchar), iperf, …</li></ul></li></ul><h2 id="measurement-tools"><a class="markdownIt-Anchor" href="#measurement-tools"></a> Measurement Tools</h2><p><strong>Packet Tracers</strong> (e.g. Wireshark)</p><ul><li>捕捉raw data (packets, segments, msgs, payload, protocol headers)</li><li>优点: 能看到所有东西(也是隐私缺点)</li><li>缺点: capture有带宽限制、内存和处理速度限制、mental/cognitive limitations</li></ul><p><strong>Simple Network Management Protocol (SNMP)</strong></p><ul><li><p>created for <strong>network management services</strong></p></li><li><p>SNMP传输的是 <strong>Management Information Base (MIB)</strong></p></li><li><p>SNMP使用<strong>Manager and Agent</strong> architecture (类似于client-server)</p><ul><li><p><strong>manager</strong>监控网络，发送命令，装有SNMP Manager软件。也叫做<strong>Network Management Station (NMS)</strong></p></li><li><p><strong>agent</strong>: 存储网络信息MIB，在manager发出命令时发送回复。装有SNMP Agent软件</p><img src="/2025/056_cmu_14740/SNMP-arch.png" srcset="/img/loading.gif" lazyload></li></ul></li><li><p>SNMP counters</p><ul><li>可以问router每一个interface有多少traffic, router把这些counter存在MIB database中 (byte counts, packet counts, …)</li><li>SNMP Manager 可以定期 <strong>poll</strong> the router或其它支持SNMP的设备来获取SNMP counters</li></ul></li><li><p>SNMP usage</p><ul><li><strong>billing</strong>: 使用packet/byte count来决定对link(interface)收多少费</li><li><strong>Multi Router Traffic Grapher (MRTG)</strong><ul><li>使用SNMP counter建立。Plot出input/output bandwidth(或别的东西, 比如router的cpu和内存占用）随时间的变化</li><li>useful for <strong>eyeballing</strong> network anomalies (Tomography): eyeball的意思是根据外部的observation推断出内部的characteristics</li></ul></li></ul></li><li><p>SNMP’s limitations</p><ul><li>SNMP cannot tell the whole story about network traffic (SNMP只有counter无法表达全部信息，例如traffic的类型, web, p2p, DNS等，也无法表达流量的来源和去向)</li></ul></li></ul><p><strong>Traffic Matrix</strong></p><p>Traffic matrix是特定network node pair之间有多少数据传输 (How many traffic from A to B?)</p><p>Internal traffic matrix: <strong>PoP to PoP</strong> (PoP: point of presence)</p><p>External traffic matrix: PoP to external AS</p><p>SNMP counter不能帮助找到traffic matrix</p><img src="/2025/056_cmu_14740/snmp-traffic-matrix.png" srcset="/img/loading.gif" lazyload><h2 id="netflow"><a class="markdownIt-Anchor" href="#netflow"></a> NetFlow</h2><p><strong>Network Flow</strong>: stream of packets between the <strong>same</strong> source node and destination node</p><p>通常有7个field来identify互联网中的Network Flow</p><ul><li><strong>source IP</strong></li><li><strong>dest IP</strong></li><li><strong>Layer 3 protocol type</strong></li><li><strong>Type of Service (ToS)</strong></li><li><strong>src port</strong></li><li><strong>dest port</strong></li><li><strong>input logical interface/link</strong></li></ul><p>前三个从IP header(network layer)获得，src port和dest port由TCP/UDP header(transport layer)获得，最后一项由router获得</p><p>router会存储一张表，记录每个flow information(7个field)有多少packet, packet counts</p><p><strong>NetFlow</strong>: Tool to collect Network Flow Records (flow data) at a router</p><ul><li><p>cisco proprietary tool (cisco专有的一个工具，但大部分其它网络提供商也有类似的工具)</p><p>一开始是一个cache用来提高lookup的性能：如果incoming packets are identified by flow, 那么就不需要查找forwarding table</p></li><li><p><strong>IPFIX (IP Flow Information Expert)</strong></p></li><li><p>常用于large transit providers (e.g. Tier-1 ISP)</p></li></ul><p><strong>Cisco NetFlow</strong></p><p>每个router的interface有一张自己的flow table / flow cache存储flow records。一条flow record有以下几项</p><ul><li>Flow ID (7 identifiers possible)</li><li>Byte counts, Packet counts per flow</li><li>IP addr &amp; ports</li><li>Timestamps for flow start and end times</li><li>outgoing interface</li></ul><p>新来的packet先查flow cache/flow table是否有这条entry，如果有就更新counters和timestamps，如果没有则创建新的entry</p><p>Flow records定期会被导出到Data collection and analysis server上，使用UDP。以下时刻会purge导出</p><ul><li>当一条flow idle了很长时间（一段时间没有新flow）。默认为15秒</li><li>Long-lived flows会自动过期。默认为30秒</li><li>cache满了</li><li>TCP connection使用FIN或RST已经结束</li></ul><p><strong>NetFlow Sampling</strong></p><p>如果检查每router的interface接收到的每一个packet，不scalable（太多了），所以需要sampling</p><ul><li><strong>1-in-N packet sampling</strong>: 例如每100个packets查一个。Data collection and analysis server需要乘上sample rate的倒数</li><li>Why sample? Performance (DRAM提升速度、处理器提升速度远小于网速提升速度) &amp; Memory (Tier-1 ISP能看到很多很多flow；DoS攻击下这些flow会让路由器存不下)</li></ul><p>Question: 为什么只有Tier-1用NetFlow，小的不用？</p><ul><li>data rate is much lower than in backbone networks</li><li>使用更精确的测量标准 e.g. link taps</li><li>能收集raw packet headers</li><li>connectivity更简单 e.g. a single provider</li><li>我们不关心traffic matrix to external AS</li><li>没有需要收费的客户</li><li>internal connectivity本身就不复杂</li></ul><h2 id="argus"><a class="markdownIt-Anchor" href="#argus"></a> Argus</h2><p>network monitoring centre</p><h2 id="pchar"><a class="markdownIt-Anchor" href="#pchar"></a> Pchar</h2><ul><li>measurements between two Internet hosts (是pathchar的重新实现，测量throughput和RTT)</li></ul><h2 id="iperf"><a class="markdownIt-Anchor" href="#iperf"></a> Iperf</h2><ul><li>对最大带宽的测量</li></ul><h1 id="lec-18-queueing-theory"><a class="markdownIt-Anchor" href="#lec-18-queueing-theory"></a> Lec 18. Queueing Theory</h1><p>TODO</p><h1 id="lec-19-congestion-control-routers-view"><a class="markdownIt-Anchor" href="#lec-19-congestion-control-routers-view"></a> Lec 19. Congestion Control: Router’s View</h1><h2 id="queueing-disciplines"><a class="markdownIt-Anchor" href="#queueing-disciplines"></a> Queueing Disciplines</h2><p>Router (位于network layer) 中的queueing algorithm需要做两件事情</p><ul><li><strong>packet scheduling</strong>: 决定从queue中选择packet发送的顺序，会影响packet的延迟</li><li><strong>drop policy</strong>: 如果queue满了drop哪个packet</li></ul><p>Packet scheduling / Drop policy算法</p><ul><li><p><strong>FIFO / FCFS</strong> (first in first out / first come first serve)</p><p>No priority scheme, 永远按顺序发送</p></li><li><p><strong>Drop Tail (DT)</strong> policy: buffer满了之后新来的packet会被drop</p><p>FIFO + DT 是最router中最广泛使用的组合</p></li><li><p><strong>Priority queuing (PQ)</strong>: router给每个到来的packet assign优先级，设立high, medium, low三个queue</p><p>Scheduling: 先发送高优先级的队列，一个队列里用FIFO</p><p>Drop: buffer满的时候丢弃最低优先级的</p><p>问题：如果来了很多高优先级的packets，则低优先级的packet会有很长的delay</p></li><li><p><strong>Round Robin Queuing (RRQ)</strong>: 对每个flow创建一个buffer，然后路由器轮流从这些buffer里面取</p><p>如果一个Flow发送得太快，那么只有它自己的buffer会满，不会影响别人</p><p>每个Flow可以有不同的drop policy (e.g. DT)</p><p>Flow的判断方法可以自定义，可以使用7个fields，也可以只使用src ip, dst ip, 等等</p><p>问题：packet的长度不同，如果一个flow发送的packet size很大，就可以用来抢占带宽</p></li><li><p><strong>Fair Queueing (FQ)</strong></p><p>Fairness desired: bit-by-bit RR transmission. 这样子最公平，但不能实现，因为router的hop-by-hop, store-and-forward model, router无法每次只发送1个bit</p><p>解决方法: 对每个flow，计算每个在queue里的packet的transmission finishing time，排序，time最小的先发</p><p>如果两个packet同一时刻到达，根据finishing transmission time判断谁先发；如果路由器已经开始发送一个packet，不会中断</p><p>achieves <strong>maximum-minimum fairness</strong>: maximize the minimum data rate for any flow</p></li><li><p><strong>Weighted Fair Queueing (WFQ)</strong>: 与FQ类似，但对于每个flow buffer/queue添加权重，将权重算作finishing time calculations的一部分</p><p>FQ = WFQ在weight=1时的特例</p></li></ul><h2 id="random-early-drop-red-gateways"><a class="markdownIt-Anchor" href="#random-early-drop-red-gateways"></a> Random Early Drop (RED) Gateways</h2><p>通常许多TCP CC算法需要制造出loss之后才能发现可用的带宽。能否在congestion发生之前就加以避免？</p><p>因为只有router能够知道buffer占用率，有没有占满，所以可以让router来提供反馈 ==&gt; RED gateways</p><p><strong>Random Early Drop (RED)</strong></p><ul><li><p>Router-centric congestion control (仍然利用end-hosts的TCP CC)</p></li><li><p><strong>Active Queue Management (AQM) scheme</strong>: 在buffer还没有满的时候，通过给一个connection随机丢包来让那个connection的TCP得知拥堵状况。也可以将那个packet标记 <strong>Explicit Congestion Notification (ECN)</strong> flag(而不丢包)来通知TCP</p></li><li><p>RED Design 目标</p><ul><li><p>Reduce persistent queueing delay (防止因buffer满丢包造成的高延迟)</p></li><li><p>Reduce unnecessary packet drops in some cases</p></li><li><p>Reply on TCP to notify hosts (i.e. senders) to reduce the send rate</p></li><li><p>Control average queue size (控制平均queue的大小在可控范围内)</p></li><li><p>avoid global synchronization (不想让所有connection同时检测到loss而back off，同时增加send rate)</p></li><li><p>avoid bias against <strong>bursty traffic</strong>: 避免对bursty traffic造成偏见，避免频繁从bursty traffic丢包</p><p>(bursty traffic指短时间内突然发很多packet然后长时间空闲的traffic，例如浏览网页)</p></li></ul></li><li><p>RED算法：设立min threshold, max threshold, 对于每个新来的packet，计算avg queue size</p><p>如果avg &lt; min, 则正常放入queue；如果avg &gt; max, 则丢包</p><p>如果avg位于min和max中间，则计算概率pa，有pa概率丢包</p></li><li><p><strong>average queue length (avg)</strong>:</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>a</mi><mi>v</mi><msub><mi>g</mi><mi>t</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>β</mi><mo stretchy="false">)</mo><mi>a</mi><mi>v</mi><msub><mi>g</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>β</mi><mo stretchy="false">(</mo><mi>q</mi><mi>u</mi><mi>e</mi><mi>u</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">avg_t = (1-\beta) avg_{t-1} + \beta (queue\_length)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.2805559999999999em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.05278em">β</span><span class="mclose">)</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.301108em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.208331em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-.31em"></span><span class="mord mathnormal" style="margin-right:.05278em">β</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.03588em">q</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mord" style="margin-right:.02778em">_</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span></span></p><p>Bursty traffic短期的increase不会显著影响average</p></li><li><p>为什么过滤掉短期的variations？因为end host并不会立即得到反应，需要RTT/2发送方才能知道并降低发送时长，到那时congestion可能已经消失</p></li><li><p>如何设置min max thresholds?</p><ul><li>min需要足够大，让router保持稳定的利用率</li><li>max与router允许的最大average delay有关</li></ul></li><li><p>如何设置drop probability (avg在min和max之间的情况)?</p><ul><li><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>p</mi><mi>b</mi></msub><mo>=</mo><mi>m</mi><mi>a</mi><msub><mi>x</mi><mi>p</mi></msub><mo>×</mo><mrow><mo fence="true">(</mo><mfrac><mrow><mi>a</mi><mi>v</mi><mi>g</mi><mo>−</mo><mi>m</mi><mi>i</mi><msub><mi>n</mi><mrow><mi>t</mi><mi>h</mi></mrow></msub></mrow><mrow><mi>m</mi><mi>a</mi><msub><mi>x</mi><mrow><mi>t</mi><mi>h</mi></mrow></msub><mo>−</mo><mi>m</mi><mi>i</mi><msub><mi>n</mi><mrow><mi>t</mi><mi>h</mi></mrow></msub></mrow></mfrac><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">p_b = max_p \times \left( \frac{avg - min_{th}}{max_{th}-min_{th}} \right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.33610799999999996em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8694379999999999em;vertical-align:-.286108em"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.15139200000000003em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-.95003em"></span><span class="minner"><span class="mopen delimcenter" style="top:0"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3365200000000002em"><span style="top:-2.3139999999999996em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.33610799999999996em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.33610799999999996em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.33610799999999996em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.8360000000000001em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0"><span class="delimsizing size3">)</span></span></span></span></span></span></span></p><p>这样是线性关系，avg接近min时值接近0，接近max时值接近1</p></li><li><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>p</mi><mi>a</mi></msub><mo>=</mo><mfrac><msub><mi>p</mi><mi>b</mi></msub><mrow><mn>1</mn><mo>−</mo><mo stretchy="false">(</mo><mi>c</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mo>×</mo><msub><mi>p</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">p_a = \frac{p_b}{1 - (count \times p_0)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:2.04356em;vertical-align:-.936em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.33610799999999996em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.936em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>count指距离上次drop已经有多少个packet没有被drop了</p><p>count越大，pa越大，越容易被drop</p></li></ul></li><li><p>RED的问题：仍需依赖end-hosts来遵守RED的信号</p></li></ul><p><strong>SPRED</strong></p><ul><li>因为RED算法是floyd在小网络模拟上做的，现如今网络状况、applications和traffic mix已经发生很大变化</li><li>SPRED: Smith Predictor for RED: 使用Smith Predictor (一种delay compensator)</li></ul><h1 id="lec-20-data-link-layer-and-ethernet"><a class="markdownIt-Anchor" href="#lec-20-data-link-layer-and-ethernet"></a> Lec 20. Data Link Layer and Ethernet</h1><h2 id="data-link-layer"><a class="markdownIt-Anchor" href="#data-link-layer"></a> Data Link Layer</h2><p>Data Link Layer在相邻节点间传输<strong>Frames</strong></p><p>为network layer提供服务(hop-by-hop的通信)，由physical layer支撑其服务(在link上传输bits)</p><p>常被叫做 <strong>MAC Layer</strong></p><p><strong>Link</strong>: 连接相邻节点的communication channel. 分为<strong>point-to-point</strong>和<strong>broadcast</strong> (many to many) 两种</p><p>Router能够访问多个Data Link Layers(每个interface有一个Data link layer).</p><h3 id="data-link-layer的主要功能"><a class="markdownIt-Anchor" href="#data-link-layer的主要功能"></a> Data Link Layer的主要功能</h3><ul><li><strong>Framing</strong>: 将一个从network layer接收到的packet封装成<strong>frame</strong>(添加<strong>header</strong>和<strong>trailer</strong>), identify <strong>MAC address</strong></li><li>Define the <strong>link access rules</strong> for multiple users: 使用MAC协议。点对点很好实现，broadcast复杂。</li><li><strong>Error detection</strong>: 如果接收方接收到的frame有错误，则可能丢弃或者发出信号请求重发等，取决于data link layer protocol。</li><li><strong>Error coorrection</strong>: 如果接收方检测到错误，不告知sender，自行修复。同样取决于data link layer protocol。</li></ul><h3 id="mtu"><a class="markdownIt-Anchor" href="#mtu"></a> MTU</h3><p><strong>Maximum Transmission Unit (MTU)</strong>: data link layer frame的最大携带的data大小，不包括data link layer的header和trailer</p><p>不同的Data Link Layer中有不同的frame size，不同的MTU</p><h2 id="mac"><a class="markdownIt-Anchor" href="#mac"></a> MAC</h2><p><strong>Multiple (Media/Medium) Access Control Protocols</strong></p><p>有两种类型的Data Link Layer <strong>Links</strong></p><ul><li><p>点对点 <strong>point-to-point</strong> / sender to receiver: <strong>Point-to-Point Protocol (PPP)</strong></p></li><li><p><strong>Broadcast</strong> / many-to-many: 共享介质，能听到别人的通信，同一时刻只能有一对人通信</p><p>大于2个节点同时传输会导致<strong>collision</strong> --&gt; <strong>Multiple Access Control (MAC)</strong> 协议，约定如何避免collision</p></li></ul><p>MAC协议的分类：</p><ul><li><p><strong>Channel Partitioning</strong>: 把channel分块(时域或频域等), 总带宽为R，分成N个channel</p><p>但如果有小于N个节点需要发送，就会导致浪费</p></li><li><p><strong>Taking Turns</strong>: 类似TDM(时分复用), 但是需要发送更多数据的节点可以占有更长的turns</p><ul><li><strong>Polling protocol</strong>: 一个primary节点和多个secondary节点，primary节点轮流询问其它节点是否需要发送数据。蓝牙就是这种。</li><li><strong>Token-passing</strong>: 传递一个特殊的Frame (token)，拿到token的节点才能发送</li></ul></li><li><p><strong>Random Access</strong>: 发送方永远占有总带宽，会发生collision，要么avoid要么detect</p><ul><li><p><strong>Collision Detection / CSMA\CD</strong> (例如Ethernet)</p><p>Carrier sense (CS): 先Listen/sense，如果监听到没有人再发才开始传输；否则随机等待一段时间</p><p>Multiple Access (MA): 发送数据(在共享介质上broadcast出去)</p><p>Collision detection (CD): 发送之前先sense，没人才发</p><p>需要有min transmission time，否则如果发送时间太短，可能发送方检测不到collision</p></li><li><p><strong>Collision Avoidance / CSMA\CA</strong> (例如wireless)</p><p>没讲</p></li></ul></li></ul><h2 id="ethernet"><a class="markdownIt-Anchor" href="#ethernet"></a> Ethernet</h2><p><strong>Ethernet services</strong></p><ul><li>connectionless</li><li>unreliable</li><li>In-order delivery 顺序不变</li></ul><p><strong>Ethernet Topology</strong></p><ul><li><strong>Bus topology</strong>: 所有人连在一根线上</li><li><strong>Star topology</strong>: 所有节点连在一个设备上(hub/switch)</li></ul><p><strong>Ethernet Frame</strong></p><ul><li><p><strong>Preamble</strong>: 8字节，7字节的10101010+1字节的10101011</p><p>用于同步发送方和接收方的速度，正确接收上面的pattern代表速度正确</p></li><li><p><strong>Dest + Source addresses</strong>: 各6字节，MAC地址的高3字节代表生产厂商，低3字节代表设备唯一标识</p><p>destination MAC地址可由IP地址推断而来 (ARP, 下节课讲)</p></li><li><p><strong>Type</strong>: 2字节，代表上层协议(例如IPv4)</p></li><li><p><strong>Data</strong>: 46-1500Bytes (Ethernet的MTU为1500)</p></li><li><p><strong>CRC</strong> （Cyclic Redundancy Check): 末尾的trailer，用于错误检测</p></li><li><p>总的frame最小长度为64bytes (data,header,CRC) + preamble = 72 bytes, 足够在100米长的线缆上保证collision detection</p></li><li><p>总的frame最大长度为1526bytes</p></li></ul><p><strong>CSMA/CD Transmission Algorithm</strong></p><ul><li><p>Ethernet interface/adapter (Network Interface Card (NIC))从Network layer接收到一个packet，并构建frame</p></li><li><p>Ethernet interface 先监听是否有96-bit时长的空闲channel, 等到有连续96-bit空闲再开始发送</p></li><li><p>Transmitting的同时也要监听，比较发出的信号和收到的信号，如果不同，则标识有collision</p><p>发生<strong>collision</strong>的时候，abort原有的传输，并发送<strong>48-bit</strong>的<strong>Jam signal</strong></p><p>发送Jam signal之后进入<strong>Exponential Backoff</strong></p></li><li><p>Exponential Backoff: 对第n次collision，在0到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.747722em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.664392em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span>间取随机数K(但不能超过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>即1024), 然后等待 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>512</mn><mo>×</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">512 \times k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span></span></span></span> bit的时长后，重新进入第二步（监听96-bit空闲）</p></li><li><p>如果发生16次collision则放弃发送</p></li></ul><h1 id="lec-21-data-link-layer-arp-devices"><a class="markdownIt-Anchor" href="#lec-21-data-link-layer-arp-devices"></a> Lec 21. Data Link Layer: ARP &amp; Devices</h1><h2 id="arp-address-resolution-protocol"><a class="markdownIt-Anchor" href="#arp-address-resolution-protocol"></a> ARP (Address Resolution Protocol)</h2><p>MAC地址和IP地址都能identify设备，但是有以下的不同</p><ul><li>MAC用于<strong>local identification</strong> (<strong>node by node</strong>), IP用于<strong>global identification</strong> (the Internet)</li><li>MAC在Layer 2 (<strong>data link layer</strong>), IP在Layer 3 (<strong>network layer</strong>)</li><li>MAC是物理地址, IP是逻辑地址</li><li>MAC有48-bit, IP有32bit(IPv4)或128bit(IPv6)</li></ul><p><strong>Local Broadcast Domain (network segment)</strong></p><ul><li>在这个network segment内，所有节点都能通过发送Layer 2 (MAC) frame来互相访问</li><li>network segment内，所有host都属于同一个subnetwork，有相同的network prefix (e.g. 192.168.0.0/16)</li><li>单条broadcast domain可能包括多个data link layer的设备 (电脑、服务器、hub等)</li></ul><p><strong>ARP</strong></p><p>ARP的任务：将network layer的地址(IP)翻译成data link layer的地址(MAC)</p><p>ARP比DNS简单，因为不需要服务器(root, TLD等), recursive navigation, proxy cache, etc. 并且范围不同，DNS需要对互联网的所有域名作转换，ARP只需要在local broadcast domain中作转换</p><p>ARP能将IPv4地址转换为MAC地址。IPv6不使用ARP，使用Neighbor Discovery Protocol (NDP).</p><p><strong>ARP Request/Reply Messages</strong>:</p><ul><li>ARP消息总共包括两个fields，总共四个addresses:<ul><li><strong>Sender</strong>: src MAC address, src IP address</li><li><strong>Target</strong>: dest MAC address, dest IP address</li></ul></li><li><strong>ARP request</strong> 发送给一个broadcast address: <code>FF:FF:FF:FF:FF:FF</code>, 所有在broadcast domain中的节点都会收到消息</li><li><strong>ARP Reply</strong>使用相同的格式，但不是broadcast !</li></ul><p><strong>ARP Table</strong></p><ul><li>每个data link layer adapter/interface (NIC) 都会存储ARP table, 保存一直的IP和MAC地址的映射关系。给定IP地址，先查table，查不到再去发送ARP request。</li></ul><p>Gratuitous ARP: ARP也可以用来发布广播（不遵循request/reply模式），target和sender是同一个地址，仅用于更新别人的ARP table</p><h2 id="data-link-layer-interconnections"><a class="markdownIt-Anchor" href="#data-link-layer-interconnections"></a> Data Link Layer Interconnections</h2><p>只有<strong>physical layer</strong>的设备：<strong>repeater</strong> (一对一放大信号) and <strong>hub</strong> (一对多放大信号)</p><p><strong>Hub</strong> 是一个multi-connection repeater. 只会replicate bits，相同data rates，无任何buffering, CSMA等</p><p>因为hub无法避免collision，不同data rates无法通信，所以很少使用.</p><p>所以需要一些同时能访问Physical layer和Data Link Layer的设备: <strong>LAN Bridge/Switch</strong></p><h3 id="switch"><a class="markdownIt-Anchor" href="#switch"></a> Switch</h3><p><strong>Switch (aka Bridge)</strong>: 存储并转发data link layer的frames，根据目的地的MAC地址进行选择性转发。</p><ul><li>使用CSMA/CD访问每个link</li><li>Transparent: 终端的end hosts并不知道switch的存在</li><li>不需要提前设置，会自己学习</li><li>大部分switch支持<strong>simultaneous switching</strong>: 选择性转发, 不会发生collisions, 具有full-duplex capability, 支持异构的链接</li></ul><p><strong>Switch Self-Learning Algorithm</strong></p><ul><li><p>Switch在data link level维护一个forwarding table</p></li><li><p>每一条entry包括: {MAC address, Link, TimeStamp}, 其中Time Stamp用于每60秒自动清除超时的entry</p></li><li><p>收到时，学习incoming sender的link和mac地址，转发时如果不知道目的地在哪里，则broadcast给所有link，但发送方link除外（几乎是flooding）</p></li><li><p><strong>Avoiding Loops</strong>: 如果两个LAN之间有多个path则会产生loop，解决办法是<strong>spanning tree</strong></p><p><strong>Spanning Tree (ST)</strong>: 最小能覆盖所有节点的edges集合</p><p>根据interface/link的数据传输速率决定edge weight (cost)</p><p><strong>STP Algorithm</strong>:</p><ul><li>1: 选择priority value最小的switch作为spanning tree的根节点（priority value由系统管理员决定），如果priority value相同则选择MAC地址最小的</li><li>2: 对于每个不是根节点的switch，判断root port，从root port出发到达root的cost需要最小</li><li>3: 对于每个LAN，选择designated port，这个port连接整个LAN和root switch的cost需要最小</li><li>4: 所有switch禁用不是designed也不是root的端口</li></ul><p>在最开始的时候，switches并不知道网络结构和其它人的switch ID，所以每人都认为自己是root switch，然后每隔两秒发送configuration消息: <strong>Bridge Protocol Data Unit (BDPU)</strong></p><h1 id="lec-22-virtual-data-link-layer"><a class="markdownIt-Anchor" href="#lec-22-virtual-data-link-layer"></a> Lec 22. Virtual Data Link Layer</h1><h2 id="virtual-local-area-networks-vlans"><a class="markdownIt-Anchor" href="#virtual-local-area-networks-vlans"></a> Virtual Local Area Networks (VLANs)</h2><p>VLAN是hosts之间的logical Data Link Layer connection. 它们物理上连接，逻辑上分开。</p><p>TODO</p><h1 id="lec-23-wireless"><a class="markdownIt-Anchor" href="#lec-23-wireless"></a> Lec 23. Wireless</h1><p>Friis equation: 接收到的power和发送方power的关系.</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>P</mi><mi>r</mi></msub><mo>=</mo><msub><mi>P</mi><mi>t</mi></msub><mo>×</mo><msub><mi>G</mi><mi>t</mi></msub><msub><mi>G</mi><mi>r</mi></msub><mo stretchy="false">(</mo><mi>λ</mi><mi mathvariant="normal">/</mi><mn>4</mn><mi>π</mi><msup><mi>d</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_r = P_t \times G_t G_r (\lambda/4\pi d^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.02778em">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.2805559999999999em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.2805559999999999em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.02778em">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">λ</span><span class="mord">/</span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:.03588em">π</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8641079999999999em"><span style="top:-3.113em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>接收信号的power=发送信号强度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord">×</span></span></span></span>天线增益(antenna gains)<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord">×</span></span></span></span>(波长/距离)^2</p><p>无线的挑战</p><ul><li>接收到的信号的power远小于发送方，因此接收信号时不能同时发送</li><li><strong>multipath effect</strong>: 接收方同时能看到直线收到的信号(line-of-sight, direct)和经过反射到达的信号(non-line-of-sight, bounce)</li><li><strong>hidden terminal problem</strong>: A与C相连，B与C相连，但AB隔得远看不到对方的存在，AB同时跟C传数据会导致C听不清</li><li><strong>exposed terminal problem</strong>: A发给A’, B发给B’, A想要发送时听见B在发送从而A不发了，导致两边都停止传输</li></ul><h2 id="csmaca"><a class="markdownIt-Anchor" href="#csmaca"></a> CSMA/CA</h2><p>CSMA/CD几乎不可能（CD: sense, listen while sending），因为干扰太多了，无线传输只能用CA</p><p><strong>802.11(Wi-Fi) CSMA/CA Algorithm</strong></p><ul><li><p>先监听<strong>DIFS (Carrier Sense)</strong></p><p>如果有人在通信，则exponential backoff</p><p>如果空闲，则发送整个Frame，并等待从AP发回的ACK，如果没有收到ACK则进入exponential backoff</p><p>（对比: CD是监听96-bit空闲, 这里CA是监听预先设定的DIFS的时长。CD一旦有96-bit空闲就能立刻开始发送，CA检测到有冲突则立即进exponential backoff）</p></li><li><p>接收方（AP）只会在Frame通过CRC checksum校验时，先等待一段短的时间(<strong>SIFS</strong>)之后再发AC</p></li><li><p><strong>exponential backoff</strong>有以下两种</p><ul><li>每个节点选随机时长</li><li>使用<strong>counter</strong>，每个时间片idle则counter减1，有别人在传输则保持不变，counter减到0时才可以开始传输</li></ul></li><li><p><strong>Channel reservations</strong>: 节点可以申请专属传输通道。节点发送<strong>Request to Send (RTS)</strong>, AP批准后发送<strong>Clear to Send (CTS)</strong>, 这里所有人都能听见CTS</p></li></ul></li></ul><h2 id="80211-wi-fi"><a class="markdownIt-Anchor" href="#80211-wi-fi"></a> 802.11 (Wi-Fi)</h2><p>WiFi有不同的operating modes</p><ul><li><strong>infrastructure</strong>: 需要AP, AP连接无线设备和有线网</li><li><strong>ad-hoc</strong>: 没有AP，节点间直连, node-to-node, wifi-direct</li><li><strong>point-to-point</strong>: 多个AP之间用桥连接，增大AP覆盖范围</li></ul><p><strong>802.11 Frame</strong></p><ul><li>802.11有4个MAC address</li><li>Address 1是接收方, Address 2是发送方, Address 3是连接AP的router，Address4仅用于Ad-hoc模式下forwarding使用</li><li><strong>Frame Control</strong> (2-byte), <strong>Duration</strong> (2-byte, 在这段时间内sender独享channel), 三个address, <strong>Sequence Control</strong> (2-byte, 类似RDT seq num), 第4个address, <strong>Data</strong> (最高2304-byte, 通常小于1500-byte因为受到ethernet的MTU限制), <strong>CRC</strong> (4-byte)</li></ul><p><strong>802.11 Other Stuff</strong></p><ul><li><strong>power management</strong>: 一个节点可以告诉AP接下来一段时间它会sleep，例如100ms，这段时间AP会buffer frames直到节点醒来</li><li><strong>rate adaption</strong>: 传输速率可以根据环境调节，如果有frame丢失则降低速率</li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Lecture-Notes/" class="category-chain-item">Lecture Notes</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Lecture-Notes/" class="print-no-link">#Lecture Notes</a></div></div><div class="license-box my-3"><div class="license-title"><div>[Lecture Notes] CMU 14-740 Fundamentals of Telecommunication Networks</div><div>https://www.billhu.us/2025/056_cmu_14740/</div></div><div class="license-meta"><div class="license-meta-item"><div>Author</div><div>Bill Hu</div></div><div class="license-meta-item license-meta-date"><div>Posted on</div><div>January 16, 2025</div></div><div class="license-meta-item"><div>Licensed under</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - Attribution"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2025/057_cmu_17514/" title="[Lecture Notes] CMU 17-514 Software Construction"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">[Lecture Notes] CMU 17-514 Software Construction</span> <span class="visible-mobile">Previous</span></a></article><article class="post-next col-6"><a href="/2025/054_cmu_15618/" title="[Lecture Notes] CMU 15-618 Parallel Computer Architecture &amp; Programming"><span class="hidden-mobile">[Lecture Notes] CMU 15-618 Parallel Computer Architecture &amp; Programming</span> <span class="visible-mobile">Next</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>Table of Contents</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">Search</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">Keyword</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <span>With </span><a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <i class="iconfont icon-love"></i> <a href="/about" target="_blank" rel="nofollow noopener"><span>Bill Hu</span></a><div style="font-size:.85rem"><span id="timeDate">Loading days...</span> <span id="times">Loading time...</span><script src="/js/duration.min.js"></script></div></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,t=t.getElementById("subtitle");t&&e&&e(t.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){var t;"tocbot"in window&&(tocbot.refresh(),0!==(t=jQuery("#toc")).length)&&tocbot&&0<t.find(".toc-list-item").length&&t.css("visibility","visible")}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback(function(){if("anchors"in window){anchors.removeAll();var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}})})</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">Blog works best with JavaScript enabled</div></noscript></body></html>